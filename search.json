[{"title":"Mac 截图快捷键","path":"/2022/04/02/Mac-截图快捷键/","content":"123456Shift + Command + 3 截取所有屏幕；Shift + Command + 4 截取选中范围，按一次空格后切换至截取选中窗口；Shift + Command + 5 打开傻瓜化截图 /录屏工具；+3 和 +4 的快捷键如果再加上 Option 时，截图会放在剪贴板里。"},{"title":"Mac 查看jdk安装路径","path":"/2022/02/09/Mac-查看jdk安装路径/","content":"12/usr/libexec/java_home -V"},{"title":"线程池的状态参数分析","path":"/2022/01/11/线程池的状态参数分析/","content":"线程池的状态参数分析线程池的原子变量ctl的创建如下： 1private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0)); 上面中的RUNNING为： 1private static final int RUNNING = -1 &lt;&lt; COUNT_BITS; -1做左移COUNT_BITS运算 COUNT_BITS如下： 12private static final int COUNT_BITS = Integer.SIZE - 3; 其中Integer.SIZE=32，得知COUNT_BITS为29，那么RUNNING为左移-1左移29位，-1的二进制表示为11111111111111111111111111111111，左移29位11100000000000000000000000000000。 ctlOf的计算方式如下： 1private static int ctlOf(int rs, int wc) &#123; return rs | wc; &#125; 线程的运行状态与线程数量做或运算，所以运行状态左移29位后，将高3位表示运行状态，低29位表示线程数量。 由于线程池的运行状态只有如下几种： 123456// runState is stored in the high-order bitsprivate static final int RUNNING = -1 &lt;&lt; COUNT_BITS;private static final int SHUTDOWN = 0 &lt;&lt; COUNT_BITS;private static final int STOP = 1 &lt;&lt; COUNT_BITS;private static final int TIDYING = 2 &lt;&lt; COUNT_BITS;private static final int TERMINATED = 3 &lt;&lt; COUNT_BITS; 所以高3位足以表示所有的运行状态。线程池提供了运行状态和线程数量的计算方法： 123// Packing and unpacking ctlprivate static int runStateOf(int c) &#123; return c &amp; ~CAPACITY; &#125;private static int workerCountOf(int c) &#123; return c &amp; CAPACITY; &#125; 运算常量 123456private static final int CAPACITY = (1 &lt;&lt; COUNT_BITS) - 1;CAPACITY = (1 &lt;&lt; 29) -1 = (00000000000000000000000000000001 &lt;&lt; 29) - 1 = 00100000000000000000000000000000 - 1 = 00011111111111111111111111111111 所以runStateOf 为舍弃掉低29位后的值,workerCountOf 为舍弃掉高3位后的值。","tags":["线程池"],"categories":["java"]},{"title":"log4j2 漏洞修复","path":"/2021/12/22/log4j2-漏洞修复/","content":"解决方案 添加JVM参数 1Dlog4j2.formatMsgNoLookups=true 修改配置 1log4j2.formatMsgNoLookups=True 添加环境变量 1FORMAT_MESSAGES_PATTERN_DISABLE_LOOKUPS 设置为 true 升级Apache Log4j2 相关包至最新版","categories":["java"]},{"title":"pulsar","path":"/2021/12/03/pulsar/","content":"单机版使用下载pulsarhttps://pulsar.apache.org/download/下载完成后解压 使用pulsar启动单机pulsar1$ bin/pulsar standalone 订阅一个topic12$ bin/pulsar-client consume my-topic -s &quot;first-subscription&quot; 发布一条消息12$ bin/pulsar-client produce my-topic --messages &quot;hello-pulsar&quot; 结束pulsar进程使用ctrl+c结束进程","tags":["pulsar"],"categories":["中间件"]},{"title":"MyBatis拦截器获取SQL执行时间","path":"/2021/09/24/MyBatis/","content":"拦截器实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122package com;import com.baomidou.mybatisplus.toolkit.SqlUtils;import com.baomidou.mybatisplus.toolkit.StringUtils;import com.baomidou.mybatisplus.toolkit.SystemClock;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.apache.ibatis.executor.Executor;import org.apache.ibatis.mapping.BoundSql;import org.apache.ibatis.mapping.MappedStatement;import org.apache.ibatis.mapping.ParameterMapping;import org.apache.ibatis.mapping.ParameterMode;import org.apache.ibatis.plugin.*;import org.apache.ibatis.reflection.MetaObject;import org.apache.ibatis.session.Configuration;import org.apache.ibatis.session.ResultHandler;import org.apache.ibatis.session.RowBounds;import org.apache.ibatis.type.TypeHandlerRegistry;import java.util.ArrayList;import java.util.List;import java.util.Locale;import java.util.Properties;/** * @author * @since 2021-09-24 10:59 **/@Intercepts(&#123; @Signature(type = Executor.class, method = &quot;query&quot;, args = &#123; MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class &#125;), @Signature(type = Executor.class, method = &quot;update&quot;, args = &#123; MappedStatement.class, Object.class &#125;) &#125;)public class OrderPerformanceInterceptor implements Interceptor &#123; private static final Logger logger = LoggerFactory.getLogger(OrderPerformanceInterceptor.class); /** * SQL 执行最大时长，超过自动停止运行，有助于发现问题。 */ private long maxTime = 0; private boolean format = false; public Object intercept(Invocation invocation) throws Throwable &#123; MappedStatement mappedStatement = (MappedStatement) invocation.getArgs()[0]; Object parameterObject = null; if (invocation.getArgs().length &gt; 1) &#123; parameterObject = invocation.getArgs()[1]; &#125; String statementId = mappedStatement.getId(); BoundSql boundSql = mappedStatement.getBoundSql(parameterObject); Configuration configuration = mappedStatement.getConfiguration(); String sql = SqlUtils.sqlFormat(boundSql.getSql(), format); List&lt;String&gt; params = getParams(boundSql, parameterObject, configuration); long start = SystemClock.now(); Object result = invocation.proceed(); long end = SystemClock.now(); long timing = end - start; if (sql.toLowerCase(Locale.ROOT).trim().startsWith(&quot;select&quot;)) &#123; logger.info(&quot;Time：&#123;&#125; ms - ID：&#123;&#125; SQL Params:&#123;&#125; Execute SQL：&#123;&#125;&quot;, timing, statementId, params.toString(), sql); &#125;else &#123; logger.info(&quot;Time：&#123;&#125; ms - ID：&#123;&#125; SQL Params:&#123;&#125; Execute SQL：&#123;&#125; result:&#123;&#125;&quot;, timing, statementId, params.toString(), sql, result); &#125; return result; &#125; public Object plugin(Object target) &#123; if (target instanceof Executor) &#123; return Plugin.wrap(target, this); &#125; return target; &#125; public void setProperties(Properties prop) &#123; // TODO &#125; private List&lt;String&gt; getParams(BoundSql boundSql, Object parameterObject, Configuration configuration) &#123; List&lt;ParameterMapping&gt; parameterMappings = boundSql.getParameterMappings(); TypeHandlerRegistry typeHandlerRegistry = configuration.getTypeHandlerRegistry(); List&lt;String&gt; params = new ArrayList&lt;String&gt;(); if (parameterMappings != null) &#123; for (int i = 0; i &lt; parameterMappings.size(); i++) &#123; ParameterMapping parameterMapping = parameterMappings.get(i); if (parameterMapping.getMode() != ParameterMode.OUT) &#123; Object value; String propertyName = parameterMapping.getProperty(); if (boundSql.hasAdditionalParameter(propertyName)) &#123; value = boundSql.getAdditionalParameter(propertyName); &#125; else if (parameterObject == null) &#123; value = null; &#125; else if (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) &#123; value = parameterObject; &#125; else &#123; MetaObject metaObject = configuration.newMetaObject(parameterObject); value = metaObject.getValue(propertyName); &#125; params.add(StringUtils.sqlParam(value)); &#125; &#125; &#125; return params; &#125; public long getMaxTime() &#123; return maxTime; &#125; public void setMaxTime(long maxTime) &#123; this.maxTime = maxTime; &#125; public boolean isFormat() &#123; return format; &#125; public void setFormat(boolean format) &#123; this.format = format; &#125;&#125; 配置拦截器1234567891011&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot; /&gt; &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:/sqlmap/*Mapper.xml&quot; /&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;property name=&quot;plugins&quot;&gt; &lt;array&gt; &lt;!-- 基于拦截器的实现，配置拦截器所在工程的全路径 --&gt; &lt;bean id=&quot;sqlStatementInterceptor&quot; class=&quot;com.**.interceptor.OrderPerformanceInterceptor&quot;/&gt; &lt;/array&gt; &lt;/property&gt;&lt;/bean&gt;","tags":["mybatis"],"categories":["中间件"]},{"title":"git命令行操作github超时解决方案","path":"/2021/09/17/git命令行操作github超时解决方案/","content":"设置代理(有代理) 前提情况下 是有代理 端口号是代理服务器本地端口 1234git config --global http.proxy http://127.0.0.1:1080git config --global https.proxy https://127.0.0.1:1080 设置host(无代理) 打开https://github.com.ipaddress.com/ 如下图： 把IP Address 记录下来！ 把IP Address 记录下来！ 把IP Address 记录下来！ 打开https://fastly.net.ipaddress.com/github.global.ssl.fastly.net#ipinfo 如下图： 把IP Address 记录下来！ 把IP Address 记录下来！ 把IP Address 记录下来！3. 打开https://github.com.ipaddress.com/assets-cdn.github.com 如下图： 把IP Address 记录下来！ 把IP Address 记录下来！ 把IP Address 记录下来！4. 打开电脑的hosts文件，把下列的东东写在最后，然后保存即可 123456140.82.113.4(图1的IP Address) github.com 199.232.69.194(图2的IP Address) github.global.ssl.fastly.net185.199.108.153(图3的IP Address) assets-cdn.github.com185.199.109.153(图3的IP Address) assets-cdn.github.com185.199.110.153(图3的IP Address) assets-cdn.github.com185.199.111.153(图3的IP Address) assets-cdn.github.com 在终端在输以下指令刷新DNS（需要权限）1sudo killall -HUP mDNSResponder;say DNS cache has been flushed","tags":["git"],"categories":["工具","GIT"]},{"title":"Java DES 加密工具类","path":"/2021/09/16/Java-DES-加密工具类/","content":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198package com;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import javax.crypto.Cipher;import javax.crypto.SecretKeyFactory;import javax.crypto.spec.DESKeySpec;import javax.crypto.spec.IvParameterSpec;import java.security.Key;import java.util.HashMap;import java.util.Map;/** * 加密 * * @author * @since 2021-08-30 14:14 **/public class DesPlus &#123; private static final String strDefaultKey = &quot;dhyPksiF&quot;; private static final Logger logger = LoggerFactory.getLogger(DesPlus.class); private final Map&lt;String, Cipher&gt; encryptMap = new HashMap&lt;String, Cipher&gt;(); private final Map&lt;String, Cipher&gt; decryptMap = new HashMap&lt;String, Cipher&gt;(); private static final ThreadLocal&lt;DesPlus&gt; localDesPlus = new ThreadLocal&lt;DesPlus&gt;() &#123; @Override protected DesPlus initialValue() &#123; return new DesPlus(); &#125; &#125;; private DesPlus() &#123; &#125; public static DesPlus getInstance() &#123; return localDesPlus.get(); &#125; public static final String ALGORITHM_DES = &quot;DES/CBC/PKCS5Padding&quot;; /** * DES算法，加密 * * @param data 待加密字符串 * @return 加密后的字节数组，一般结合Base64编码使用 * @throws Exception 异常 */ public String encode(String data) throws Exception &#123; return encode(strDefaultKey, data.getBytes()); &#125; /** * DES算法，加密 * * @param data 待加密字符串 * @param key 加密私钥，长度不能够小于8位 * @return 加密后的字节数组，一般结合Base64编码使用 * @throws Exception 异常 */ public String encode(String key, String data) throws Exception &#123; logger.info(&quot;key:&#123;&#125;|data:&#123;&#125;|start&quot;, key, data); String encode = encode(key, data.getBytes()); logger.info(&quot;key:&#123;&#125;|data:&#123;&#125;|end。&#123;&#125;&quot;, key, data, encode); return encode; &#125; /** * DES算法，加密 * * @param data 待加密字符串 * @param key 加密私钥，长度不能够小于8位 * @return 加密后的字节数组，一般结合Base64编码使用 * @throws Exception 异常 */ public String encode(String key, byte[] data) throws Exception &#123; try &#123; DESKeySpec dks = new DESKeySpec(key.getBytes()); SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DES&quot;); //key的长度不能够小于8位字节 Key secretKey = keyFactory.generateSecret(dks); Cipher cipher = Cipher.getInstance(ALGORITHM_DES); IvParameterSpec iv = new IvParameterSpec(key.getBytes()); cipher.init(Cipher.ENCRYPT_MODE, secretKey, iv); byte[] bytes = cipher.doFinal(data); return byteArrayToHexString(bytes); &#125; catch (Exception e) &#123; logger.error(&quot;key:&#123;&#125;|data:&#123;&#125;|encode error&quot;, key, new String(data), e); &#125; return &quot;&quot;; &#125; public String byteArrayToHexString(byte b[]) &#123; StringBuffer resultSb = new StringBuffer(); for (int i = 0; i &lt; b.length; i++) resultSb.append(byteToHexString(b[i])); return resultSb.toString(); &#125; private static String byteToHexString(byte b) &#123; int n = b; if (n &lt; 0) n += 256; int d1 = n / 16; int d2 = n % 16; return hexDigits[d1] + hexDigits[d2]; &#125; /** * DES算法，解密 * * @param data 待解密字符串 * @param key 解密私钥，长度不能够小于8位 * @return 解密后的字节数组 */ public byte[] decode(String key, byte[] data) &#123; try &#123; DESKeySpec dks = new DESKeySpec(key.getBytes()); SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DES&quot;); //key的长度不能够小于8位字节 Key secretKey = keyFactory.generateSecret(dks); Cipher cipher = Cipher.getInstance(ALGORITHM_DES); IvParameterSpec iv = new IvParameterSpec(key.getBytes()); cipher.init(Cipher.DECRYPT_MODE, secretKey, iv); return cipher.doFinal(data); &#125; catch (Exception e) &#123; logger.error(&quot;key:&#123;&#125;|data:&#123;&#125;|decode error&quot;, key, new String(data), e); &#125; return new byte[0]; &#125; /** * 获取编码后的值 * * @param data 解码数据 * @return 解码后的数据 */ public String decodeValue(String data) &#123; return decodeValue(strDefaultKey, data); &#125; /** * 获取编码后的值 * * @param key * @param data * @return * @throws Exception */ public String decodeValue(String key, String data) &#123; byte[] datas; String value = null; try &#123; datas = decode(key, hexStr2ByteArr(data)); value = new String(datas); &#125; catch (Exception e) &#123; value = &quot;&quot;; &#125; return value; &#125; public byte[] hexStr2ByteArr(String strIn) &#123; byte[] arrB = strIn.getBytes(); int iLen = arrB.length; // 两个字符表示一个字节，所以字节数组长度是字符串长度除以2 byte[] arrOut = new byte[iLen / 2]; for (int i = 0; i &lt; iLen; i = i + 2) &#123; String strTmp = new String(arrB, i, 2); arrOut[i / 2] = (byte) Integer.parseInt(strTmp, 16); &#125; return arrOut; &#125; public static void main(String[] args) throws Exception &#123; DesPlus instance = getInstance(); String encode = instance.encode(&quot;18000000000&quot;); System.out.println(encode); System.out.println(instance.decodeValue(encode)); &#125;&#125;"},{"title":"Beyond Compare激活","path":"/2021/09/16/Beyond-Compare激活/","content":"Beyond Compare 4.xLicensed to: ASIO AllsoftinoneQuantity: 1 userSerial number: 1822-9597License type: Pro Edition for Linux First delete away trial mode: 1sudo rm -rf ~/.config/bcompare #thinks bensonkb 1sudo sed -i &quot;s/keexjEP3t4Mue23hrnuPtY4TdcsqNiJL-5174TsUdLmJSIXKfG2NGPwBL6vnRPddT7tH29qpkneX63DO9ECSPE9rzY1zhThHERg8lHM9IBFT+rVuiY823aQJuqzxCKIE1bcDqM4wgW01FH6oCBP1G4ub01xmb4BGSUG6ZrjxWHJyNLyIlGvOhoY2HAYzEtzYGwxFZn2JZ66o4RONkXjX0DF9EzsdUef3UAS+JQ+fCYReLawdjEe6tXCv88GKaaPKWxCeaUL9PejICQgRQOLGOZtZQkLgAelrOtehxz5ANOOqCaJgy2mJLQVLM5SJ9Dli909c5ybvEhVmIC0dc9dWH+/N9KmiLVlKMU7RJqnE+WXEEPI1SgglmfmLc1yVH7dqBb9ehOoKG9UE+HAE1YvH1XX2XVGeEqYUY-Tsk7YBTz0WpSpoYyPgx6Iki5KLtQ5G-aKP9eysnkuOAkrvHU8bLbGtZteGwJarev03PhfCioJL4OSqsmQGEvDbHFEbNl1qJtdwEriR+VNZts9vNNLk7UGfeNwIiqpxjk4Mn09nmSd8FhM4ifvcaIbNCRoMPGl6KU12iseSe+w+1kFsLhX+OhQM8WXcWV10cGqBzQE9OqOLUcg9n0krrR3KrohstS9smTwEx9olyLYppvC0p5i7dAx2deWvM1ZxKNs0BvcXGukR+/g&quot; /usr/lib/beyondcompare/BCompare Then restart BC, click “Enter License”: 12345678--- BEGIN LICENSE KEY ---ayvZeJDYPBHS4J-1K6g6bDBuPoo0G-oGAq35blZtAoRqC-qQeSz28XAzX6nTx9laTMLRCp6nAIhHNGZ2ehkeUfbnFaxEeLvI8fJavn-XQLNbOumCLUqgdNbNMZiFRU03+OTQnw4V-E2YKTYi-LkgPzE6R-yIJGDNWfxH2AdpIgg8rlpsbrTs9Dt1zysUfvAEi0dKbmGIi3rqf7yWmwDh1AI5VyoWFIejvJwJLmlr2CjQ1VZ3DySCfBDuKcYmOCeK7jzEWPUnAw+f9360nIiiNEB0YGkwBkdtgaKEEik7aNiI3jXvp5r34wViVJCiX7m2y7pqBV9gZIvP9hP9KPnP++++--- END LICENSE KEY ----- or 123--- BEGIN LICENSE KEY ---GXN1eh9FbDiX1ACdd7XKMV7hL7x0ClBJLUJ-zFfKofjaj2yxE53xauIfkqZ8FoLpcZ0Ux6McTyNmODDSvSIHLYhg1QkTxjCeSCk6ARz0ABJcnUmd3dZYJNWFyJun14rmGByRnVPL49QH+Rs0kjRGKCB-cb8IT4Gf0Ue9WMQ1A6t31MO9jmjoYUeoUmbeAQSofvuK8GN1rLRv7WXfUJ0uyvYlGLqzq1ZoJAJDyo0Kdr4ThF-IXcv2cxVyWVW1SaMq8GFosDEGThnY7C-SgNXW30jqAOgiRjKKRX9RuNeDMFqgP2cuf0NMvyMrMScnM1ZyiAaJJtzbxqN5hZOMClUTE+++--- END LICENSE KEY ----- For windows: 12345678--- BEGIN LICENSE KEY ---H1bJTd2SauPv5Garuaq0Ig43uqq5NJOEw94wxdZTpU-pFB9GmyPk677gJvC1Ro6sbAvKR4pVwtxdCfuoZDb6hJ5bVQKqlfihJfSYZt-xVrVU27+0JahFbqTmYskatMTgPyjvv99CF2Te8ec+Ys2SPxyZAF0YwOCNOWmsyqN5y9tq2Kw2pjoiDs5gIH-uw5U49JzOB6otS7kThBJE-H9A76u4uUvR8DKb+VcBrWu5qSJGEnbsXNfJdq5L2D8QgRdV-sXHp2A-7j1X2n4WIISvU1V9koIySNisHFBTcWJS0sC5BTFwrtfLEE9lEwz2bxHQpWJiu12ZeKpi+7oUSqebX+--- END LICENSE KEY ----- For Mac: Open trial.key at path: /Applications/Beyond\\ Compare.app/Contents/Resources/trial.key Replace content of trial.key with:12345678--- BEGIN LICENSE KEY ---H1bJTd2SauPv5Garuaq0Ig43uqq5NJOEw94wxdZTpU-pFB9GmyPk677gJvC1Ro6sbAvKR4pVwtxdCfuoZDb6hJ5bVQKqlfihJfSYZt-xVrVU27+0JahFbqTmYskatMTgPyjvv99CF2Te8ec+Ys2SPxyZAF0YwOCNOWmsyqN5y9tq2Kw2pjoiDs5gIH-uw5U49JzOB6otS7kThBJE-H9A76u4uUvR8DKb+VcBrWu5qSJGEnbsXNfJdq5L2D8QgRdV-sXHp2A-7j1X2n4WIISvU1V9koIySNisHFBTcWJS0sC5BTFwrtfLEE9lEwz2bxHQpWJiu12ZeKpi+7oUSqebX+--- END LICENSE KEY ----- Save trial.key file &amp; restart Beyond Compare appEnjoy! for 4.2.4 or higher,4.2.5,4.2.6,4.3.7，it’s works ， this is the way which makes Always in evaluation mode 。 open Terminal, go to the dir : cd /Applications/Beyond Compare.app/Contents/MacOS change the name BCompare to BCompare.bak: mv BCompare BCompare.bak touch a file name BCompare , and chmod a+u BCompare : touch BCompare &amp;&amp; chmod a+u BCompare open BCompare with text editor, insert the script : 123#!/bin/bashrm &quot;/Users/$(whoami)/Library/Application Support/Beyond Compare/registry.dat&quot;&quot;`dirname &quot;$0&quot;`&quot;/BCompare.bak $@ restart bc . Sublime Text12345678910111213----- BEGIN LICENSE -----eldonSingle User LicenseEA7E-1122628C0360740 20724B8A 30420C09 6D7E046F3F5D5FBB 17EF95DA 2BA7BB27 CCB1494727A316BE 8BCF4BC0 252FB8FF FD97DF71B11A1DA9 F7119CA0 31984BB9 7D71700C2C728BF8 B952E5F5 B941FF64 6D7979DAB8EB32F8 8D415F8E F16FE657 A35381CC290E2905 96E81236 63D2B06D E5F01A6984174B79 7C467714 641A9013 94CA7162------ END LICENSE ------"},{"title":"上线强烈注意事项：jar冲突","path":"/2021/09/09/上线强烈：jar冲突/","content":"jar包冲突，导致 项目中已添加 12//分页插件compile &quot;com.github.pagehelper:pagehelper:4.1.3&quot; 出现问题：net.sf.jsqlparser.statement.select.PlainSelect.getGroupByColumnReferences()Ljava/util/List; 去掉或者添加 1compile group: &#x27;com.github.jsqlparser&#x27;, name: &#x27;jsqlparser&#x27;, version: &#x27;3.1&#x27;","tags":["jar"],"categories":["问题处理"]},{"title":"SpringBoot整合Mybatis使用注解实现多数据源","path":"/2021/09/02/SpringBoot整合Mybatis使用注解实现多数据源/","content":"SpringBoot整合Mybatis使用注解实现多数据源添加依赖 pom.xml 添加以下依赖 12345678910&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.4&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.21&lt;/version&gt;&lt;/dependency&gt; 配置数据源 注意事项：db后的url注意使用jdbc-url 1234567spring.datasource.first.jdbc-url=jdbc:mysql://localhost:3306/mybatis_testspring.datasource.first.username=rootspring.datasource.first.password=123456spring.datasource.second.jdbc-url=jdbc:mysql://localhost:3306/mybatis_test1spring.datasource.second.username=rootspring.datasource.second.password=123456 创建MyBatis Mapper文件db1 Mapper123456@Repositorypublic interface FirstUserMapper &#123; @Select(&quot;select * from user&quot;) List&lt;User&gt; findUser();&#125; db2 Mapper12345@Repositorypublic interface SecondUserMapper &#123; @Select(&quot;select * from user&quot;) List&lt;User&gt; findUser();&#125; 创建数据源配置数据源1234567891011121314151617@Configurationpublic class MyBatisConfigurationDatasource &#123; // 配置db1数据源 @Bean(&quot;db1&quot;) @ConfigurationProperties(prefix = &quot;spring.datasource.first&quot;) public DataSource dataSource1() &#123; return DataSourceBuilder.create().build(); &#125; // db2数据源 @Bean(&quot;db2&quot;) @ConfigurationProperties(prefix = &quot;spring.datasource.second&quot;) public DataSource dataSource2() &#123; return DataSourceBuilder.create().build(); &#125;&#125; MyBatis数据源配置db1数据源12345678910111213141516171819202122232425262728@Configuration// 配置扫描mapper路径@MapperScan(value = &quot;com.example.springbootmybatis.first&quot;, sqlSessionFactoryRef = &quot;sqlSessionFactoryDb1&quot;)public class Db1Config &#123; @Autowired @Qualifier(&quot;db1&quot;) private DataSource dataSource; // 创建SqlSessionFactory @Bean public SqlSessionFactory sqlSessionFactoryDb1() &#123; SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean(); sqlSessionFactoryBean.setDataSource(dataSource); try &#123; return sqlSessionFactoryBean.getObject(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null; &#125; // 创建SqlSessionTemplate @Bean public SqlSessionTemplate sqlSessionTemplate1() &#123; return new SqlSessionTemplate(sqlSessionFactoryDb1()); &#125;&#125; db2数据源12345678910111213141516171819202122232425262728@Configuration// 配置扫描mapper路径@MapperScan(value = &quot;com.example.springbootmybatis.first&quot;, sqlSessionFactoryRef = &quot;sqlSessionFactoryDb1&quot;)public class Db1Config &#123; @Autowired @Qualifier(&quot;db1&quot;) private DataSource dataSource; // 创建SqlSessionFactory @Bean public SqlSessionFactory sqlSessionFactoryDb1() &#123; SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean(); sqlSessionFactoryBean.setDataSource(dataSource); try &#123; return sqlSessionFactoryBean.getObject(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null; &#125; // 创建SqlSessionTemplate @Bean public SqlSessionTemplate sqlSessionTemplate1() &#123; return new SqlSessionTemplate(sqlSessionFactoryDb1()); &#125;&#125; 测试测试接口12345678910111213141516171819202122@RestControllerpublic class TestController &#123; // 注入数据源1Mapper @Autowired FirstUserMapper firstUserMapper; // 注入数据源2Mapper @Autowired SecondUserMapper secondUserMapper; @GetMapping(&quot;getUser1&quot;) public String findUser1() &#123; List&lt;User&gt; user1 = firstUserMapper.findUser(); List&lt;User&gt; user2 = secondUserMapper.findUser(); System.out.println(user1); System.out.println(user2); Map&lt;String, List&lt;User&gt;&gt; map = new HashMap&lt;&gt;(); map.put(&quot;first&quot;, user1); map.put(&quot;second&quot;, user2); return JSON.toJSONString(map); &#125;&#125; 查看结果浏览器访问localhost:8080/getUser1 看到以下两个数据源数据，可证明数据源有效： 12345678910111213141516171819202122&#123; &quot;first&quot;: [ &#123; &quot;id&quot;: 1, &quot;name&quot;: &quot;name&quot; &#125;, &#123; &quot;id&quot;: 2, &quot;name&quot;: &quot;test&quot; &#125;, &#123; &quot;id&quot;: 3, &quot;name&quot;: &quot;213&quot; &#125; ], &quot;second&quot;: [ &#123; &quot;id&quot;: 1, &quot;name&quot;: &quot;db2&quot; &#125; ]&#125; 其它问题打印日志在applicatio.properties添加以下配置即可在控制台查看sql执行日志 123# 项目日志目录的日志级别logging.level.sql=debugmybatis.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl 双数据源打印日志MyBatis配置双数据源后会导致日志不打印，修改配置日志level可解决 12logging.level.com.example.springbootmybatis=debug# 配置到具体目录","tags":["SpringBoot"],"categories":["Spring","SpringBoot"]},{"title":"MySQL,PostgreSQL 按 年、季、月、周、天 统计","path":"/2021/09/02/MySQL-PostgreSQL-按-年、季、月、周、天-统计/","content":"MySQL,PostgreSQL 按 年、季、月、周、天 统计MySQL按日1SELECT COUNT(*),DATE(CreateTime) FROM t_voipchannelrecord WHERE YEAR(CreateTime)=&#x27;2016&#x27; GROUP BY DAY(CreateTime) 按周123456789-- SELECT COUNT(*),WEEK(CreateTime) FROM t_voipchannelrecord WHERE MONTH(CreateTime) = &#x27;8&#x27; GROUP BY WEEK(CreateTime) -- 周一到周五每天的统计结果SELECT COUNT(*),DAYNAME(CreateTime) FROM t_voipchannelrecord WHERE YEAR(CreateTime) = &#x27;2016&#x27; GROUP BY DAYNAME(CreateTime) -- 统计本周数据SELECT COUNT(*) FROM t_voipchannelrecord WHERE MONTH(CreateTime) = MONTH(CURDATE()) AND WEEK(CreateTime) = WEEK(CURDATE()) 按月统计1SELECT COUNT(*),MONTH(CreateTime) FROM t_voipchannelrecord WHERE YEAR(CreateTime) = &#x27;2016&#x27; GROUP BY MONTH(CreateTime) 按季统计1SELECT COUNT(*),QUARTER(CreateTime) FROM t_voipchannelrecord WHERE YEAR(CreateTime) = &#x27;2016&#x27; GROUP BY QUARTER(CreateTime) 按年统计1SELECT COUNT(*),YEAR(CreateTime) FROM t_voipchannelrecord GROUP BY YEAR(CreateTime) PostgreSQL按日统计123to_char( time, &#x27;yyyy-MM-dd&#x27; ) AS timeGROUP BY to_char(time, &#x27;yyyy-MM-dd&#x27; ) 按月统计123to_char(time, &#x27;yyyy-MM&#x27; ) AS timeGROUP BY to_char(time, &#x27;yyyy-MM&#x27; ) 按年统计123to_char( time,&#x27;yyyy&#x27; ) AS timeGROUP BY to_char( time,&#x27;yyyy&#x27; ) 按小时统计123to_char(time, &#x27;yyyy-MM-dd HH&#x27; ) AS timeGROUP BY to_char( time, &#x27;yyyy-MM-dd HH&#x27; ) 按分钟统计123to_char( time, &#x27;yyyy-MM-dd HH:mm&#x27; ) AS timeGROUP BY to_char( time, &#x27;yyyy-MM-dd HH:mm&#x27; ) 按周统计按周统计最简单法 对时间row_date字段做处理，变成对应日期周一时间，然后按这个周一的时间去统计。减1的操作表示为对应日期的星期一，减1,2,3,4,5,6,7分别是对应日期的周一，周二，周三，周四，周五、周六、周日。 to_char( time-(extract (dow from time) - 1 ||’day’)::interval,’yyyy-MM-dd’) row_date 然后按上面的语句分组统计即可实现按周统计，下面对应分组函数 GROUP BY to_char(time-(extract (dow from time) - 1 ||’day’)::interval,’yyyy-MM-dd’)","tags":["MySQL"],"categories":["中间件"]},{"title":"DES可逆加密算法","path":"/2021/09/02/DES可逆加密算法/","content":"DES可逆加密算法对敏感信息进行加密123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164package com;import javax.crypto.Cipher;import java.security.Key;import java.util.HashMap;import java.util.Map;/** * 加密 * * @author * @since 2021-08-30 14:14 **/public class DesPlus &#123; private static final String strDefaultKey = &quot;dhyPksiF&quot;; private final Map&lt;String, Cipher&gt; encryptMap = new HashMap&lt;String, Cipher&gt;(); private final Map&lt;String, Cipher&gt; decryptMap = new HashMap&lt;String, Cipher&gt;(); private static final ThreadLocal&lt;DesPlus&gt; localDesPlus = new ThreadLocal&lt;DesPlus&gt;() &#123; @Override protected DesPlus initialValue() &#123; return new DesPlus(); &#125; &#125;; private DesPlus() &#123; &#125; public static DesPlus getInstance() &#123; return localDesPlus.get(); &#125; public String encrypt(String str) &#123; return encrypt(str, strDefaultKey); &#125; public String encrypt(String str, String key) &#123; if (str == null) &#123; return null; &#125; if (key == null || key.length() &lt; 8) &#123; return null; &#125; Cipher encryptCipher = encryptMap.get(key); if (encryptCipher == null) &#123; try &#123; Key k = getKey(key); encryptCipher = Cipher.getInstance(&quot;DES&quot;); encryptCipher.init(Cipher.ENCRYPT_MODE, k); encryptMap.put(key, encryptCipher); &#125; catch (Exception e) &#123; throw new RuntimeException(e.getMessage(), e); &#125; &#125; try &#123; byte[] bs = str.getBytes(&quot;utf-8&quot;); bs = encryptCipher.doFinal(bs); return byteArrayToHexString(bs); &#125; catch (Exception e) &#123; return null; &#125; &#125; public String decrypt(String str) &#123; return decrypt(str, strDefaultKey); &#125; public String decrypt(String str, String key) &#123; if (str == null) &#123; return null; &#125; if (key == null || key.length() &lt; 8) &#123; return null; &#125; Cipher decryptCipher = decryptMap.get(key); if (decryptCipher == null) &#123; try &#123; Key k = getKey(key); decryptCipher = Cipher.getInstance(&quot;DES&quot;); decryptCipher.init(Cipher.DECRYPT_MODE, k); decryptMap.put(key, decryptCipher); &#125; catch (Exception e) &#123; throw new RuntimeException(e.getMessage(), e); &#125; &#125; try &#123; byte[] bs = hexStr2ByteArr(str); bs = decryptCipher.doFinal(bs); return new String(bs, &quot;utf-8&quot;); &#125; catch (Exception e) &#123; return str; &#125; &#125; private Key getKey(String key) &#123; byte[] arrBTmp = key.getBytes(); // 创建一个空的8位字节数组（默认值为0） byte[] arrB = new byte[8]; // 将原始字节数组转换为8位 for (int i = 0; i &lt; arrBTmp.length &amp;&amp; i &lt; arrB.length; i++) &#123; arrB[i] = arrBTmp[i]; &#125; // 生成密钥 Key k = new javax.crypto.spec.SecretKeySpec(arrB, &quot;DES&quot;); return k; &#125; public static String byteArrayToHexString(byte b[]) &#123; StringBuffer resultSb = new StringBuffer(); for (int i = 0; i &lt; b.length; i++) resultSb.append(byteToHexString(b[i])); return resultSb.toString(); &#125; private static String byteToHexString(byte b) &#123; int n = b; if (n &lt; 0) n += 256; int d1 = n / 16; int d2 = n % 16; return hexDigits[d1] + hexDigits[d2]; &#125; public static byte[] hexStr2ByteArr(String strIn) &#123; byte[] arrB = strIn.getBytes(); int iLen = arrB.length; // 两个字符表示一个字节，所以字节数组长度是字符串长度除以2 byte[] arrOut = new byte[iLen / 2]; for (int i = 0; i &lt; iLen; i = i + 2) &#123; String strTmp = new String(arrB, i, 2); arrOut[i / 2] = (byte) Integer.parseInt(strTmp, 16); &#125; return arrOut; &#125; public static void main(String[] args) &#123; DesPlus desPlus = new DesPlus(); String encrypt = desPlus.encrypt(&quot;1500213000000&quot;); System.out.println(encrypt); String decrypt = desPlus.decrypt(encrypt); System.out.println(decrypt); &#125;&#125;"},{"title":"Mac InetAddress.getLocalHost().getHostAddress(); 很慢","path":"/2021/09/02/Mac-InetAddress-getLocalHost-getHostAddress-很慢/","content":"Mac InetAddress.getLocalHost().getHostAddress(); 很慢解决方案 就是把本机的hostname 添加到 hosts 中，例如: 0.0.1 mac-mini.local::1 mac-mini.local 执行 scutil –set HostName “localhost”","categories":["计算机基础"]},{"title":"水平滚动页面与切换页面冲突，关闭手势切换页面","path":"/2021/09/02/水平滚动页面与切换页面冲突，关闭手势切换页面/","content":"水平滚动页面与切换页面冲突，关闭手势切换页面chrome关闭1defaults write com.google.Chrome AppleEnableSwipeNavigateWithScrolls -bool FALSE 开启1defaults write com.google.Chrome AppleEnableSwipeNavigateWithScrolls -bool TRUE edge关闭1defaults write com.microsoft.edgemac AppleEnableSwipeNavigateWithScrolls -bool false 开启1defaults write com.microsoft.edgemac AppleEnableSwipeNavigateWithScrolls -bool true"},{"title":"GIT .gitignore修改后不生效解决办法","path":"/2021/09/02/GIT-gitignore修改后不生效解决办法/","content":"GIT .gitignore修改后不生效解决办法 清除本地暂存GIT数据git rm -rf –cached . 重新添加文件到暂存区git add . 重新提交文件git commit -m “update” push到分支git push origin master","tags":["git"],"categories":["工具","GIT"]},{"title":"Hello World","path":"/2021/09/02/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"},{"title":"使用zxing生成二维码","path":"/2021/03/24/使用zxing生成二维码/","content":"1、引入zxing的依赖12345&lt;dependency&gt; &lt;groupId&gt;com.google.zxing&lt;/groupId&gt; &lt;artifactId&gt;javase&lt;/artifactId&gt; &lt;version&gt;3.4.0&lt;/version&gt;&lt;/dependency&gt; 2、二维码工具类的实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193package com.psk.hms.base.util;import com.google.zxing.*;import com.google.zxing.client.j2se.BufferedImageLuminanceSource;import com.google.zxing.common.BitMatrix;import com.google.zxing.common.HybridBinarizer;import com.google.zxing.qrcode.decoder.ErrorCorrectionLevel;import javax.imageio.ImageIO;import java.awt.*;import java.awt.geom.RoundRectangle2D;import java.awt.image.BufferedImage;import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.io.OutputStream;import java.util.Hashtable;/** * 二维码生成及读取工具类 * * @author chenj. * @version 1.0 * @since 2019/3/14 18:46 */public class QRCodeUtil &#123; private static final String CHARSET = &quot;UTF-8&quot;; private static final String FORMAT_NAME = &quot;JPG&quot;; // 二维码尺寸 private static final int QRCODE_SIZE = 200; // LOGO宽度 private static final int WIDTH = 60; // LOGO高度 private static final int HEIGHT = 60; /** * 创建二维码图片 * * @param content 二维码内容 * @param logoImgPath Logo * @param needCompress 是否压缩Logo * @return 返回二维码图片 * @throws WriterException * @throws IOException BufferedImage */ private static BufferedImage createImage(String content, String logoImgPath, boolean needCompress) throws WriterException, IOException &#123; Hashtable&lt;EncodeHintType, Object&gt; hints = new Hashtable&lt;EncodeHintType, Object&gt;(); hints.put(EncodeHintType.ERROR_CORRECTION, ErrorCorrectionLevel.H); hints.put(EncodeHintType.CHARACTER_SET, CHARSET); hints.put(EncodeHintType.MARGIN, 1); BitMatrix bitMatrix = new MultiFormatWriter().encode(content, BarcodeFormat.QR_CODE, QRCODE_SIZE, QRCODE_SIZE, hints); int width = bitMatrix.getWidth(); int height = bitMatrix.getHeight(); BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB); for (int x = 0; x &lt; width; x++) &#123; for (int y = 0; y &lt; height; y++) &#123; image.setRGB(x, y, bitMatrix.get(x, y) ? 0xFF000000 : 0xFFFFFFFF); &#125; &#125; if (logoImgPath == null || &quot;&quot;.equals(logoImgPath)) &#123; return image; &#125; // 插入图片 QRCodeUtil.insertImage(image, logoImgPath, needCompress); return image; &#125; /** * 添加Logo * * @param source 二维码图片 * @param logoImgPath Logo * @param needCompress 是否压缩Logo * @throws IOException void */ private static void insertImage(BufferedImage source, String logoImgPath, boolean needCompress) throws IOException &#123; File file = new File(logoImgPath); if (!file.exists()) &#123; return; &#125; Image src = ImageIO.read(new File(logoImgPath)); int width = src.getWidth(null); int height = src.getHeight(null); if (needCompress) &#123; // 压缩LOGO if (width &gt; WIDTH) &#123; width = WIDTH; &#125; if (height &gt; HEIGHT) &#123; height = HEIGHT; &#125; Image image = src.getScaledInstance(width, height, Image.SCALE_SMOOTH); BufferedImage tag = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB); Graphics g = tag.getGraphics(); g.drawImage(image, 0, 0, null); // 绘制缩小后的图 g.dispose(); src = image; &#125; // 插入LOGO Graphics2D graph = source.createGraphics(); int x = (QRCODE_SIZE - width) / 2; int y = (QRCODE_SIZE - height) / 2; graph.drawImage(src, x, y, width, height, null); Shape shape = new RoundRectangle2D.Float(x, y, width, width, 6, 6); graph.setStroke(new BasicStroke(3f)); graph.draw(shape); graph.dispose(); &#125; /** * 生成带Logo的二维码 * * @param content 二维码内容 * @param logoImgPath Logo * @param destPath 二维码输出路径 * @param needCompress 是否压缩Logo * @throws Exception void */ public static void encode(String content, String logoImgPath, String destPath, boolean needCompress) throws Exception &#123; BufferedImage image = QRCodeUtil.createImage(content, logoImgPath, needCompress); mkdirs(destPath); ImageIO.write(image, FORMAT_NAME, new File(destPath)); &#125; /** * 生成不带Logo的二维码 * * @param content 二维码内容 * @param destPath 二维码输出路径 */ public static void encode(String content, String destPath) throws Exception &#123; QRCodeUtil.encode(content, null, destPath, false); &#125; /** * 生成带Logo的二维码，并输出到指定的输出流 * * @param content 二维码内容 * @param logoImgPath Logo * @param output 输出流 * @param needCompress 是否压缩Logo */ public static void encode(String content, String logoImgPath, OutputStream output, boolean needCompress) throws Exception &#123; BufferedImage image = QRCodeUtil.createImage(content, logoImgPath, needCompress); ImageIO.write(image, FORMAT_NAME, output); &#125; /** * 生成不带Logo的二维码，并输出到指定的输出流 * * @param content 二维码内容 * @param output 输出流 * @throws Exception void */ public static void encode(String content, OutputStream output) throws Exception &#123; QRCodeUtil.encode(content, null, output, false); &#125; /** * 二维码解析 * * @param file 二维码 * @return 返回解析得到的二维码内容 * @throws Exception String */ public static String decode(File file) throws Exception &#123; BufferedImage image; image = ImageIO.read(file); if (image == null) &#123; return null; &#125; BufferedImageLuminanceSource source = new BufferedImageLuminanceSource(image); BinaryBitmap bitmap = new BinaryBitmap(new HybridBinarizer(source)); Result result; Hashtable&lt;DecodeHintType, Object&gt; hints = new Hashtable&lt;DecodeHintType, Object&gt;(); hints.put(DecodeHintType.CHARACTER_SET, CHARSET); result = new MultiFormatReader().decode(bitmap, hints); String resultStr = result.getText(); return resultStr; &#125; /** * 二维码解析 * * @param path 二维码存储位置 * @return 返回解析得到的二维码内容 * @throws Exception String */ public static String decode(String path) throws Exception &#123; return QRCodeUtil.decode(new File(path)); &#125; /** * 判断路径是否存在，如果不存在则创建 * * @param dir 目录 */ public static void mkdirs(String dir) &#123; if (dir != null &amp;&amp; !&quot;&quot;.equals(dir)) &#123; File file = new File(dir); if (!file.isDirectory()) &#123; file.mkdirs(); &#125; &#125; &#125;&#125; 3、测试1234567891011121314151617生成不带logo的二维码public static void main(String[] args) throws Exception &#123; String dir = &quot;d:/qrcode.jpg&quot;; String content = &quot;www.baidu.com&quot;; File file = new File(dir); QRCodeUtil.encode(content, new FileOutputStream(file)); System.out.println(QRCodeUtil.decode(file));&#125;生成带logo的二维码public static void main(String[] args) throws Exception &#123; String dir = &quot;d:/qrcode.jpg&quot;; String content = &quot;www.baidu.com&quot;; String logoImgPath = &quot;d:/logo.png&quot;; File file = new File(dir); QRCodeUtil.encode(content, logoImgPath, new FileOutputStream(file), true); System.out.println(QRCodeUtil.decode(file));&#125;"},{"title":"java阻塞队列","path":"/2020/09/10/java阻塞队列/","content":"阻塞队列 方法\\处理方式 抛出异常 返回特殊值 一直阻塞 超时退出 插入方法 add(e) offer(e) put(e) offer(e,time,unit) 移除方法 remove(e) poll() take() poll(time,unit) 检查方法 element(e) peek() 不可用 不可用"},{"title":"git切换分支","path":"/2020/04/14/git切换分支/","content":"远程拉取项目1git clone xxxx.git 查看分支1git branch -a 切换分支1git checkout -b dev origin/dev 从指定分支更新项目1git pull origin dev 提交分支1git push origin dev 连接分支1git push -set upstream 查看当前 远程url1git remote -v git 帮助文档git帮助文档"},{"title":"Netty的基本使用","path":"/2020/03/25/netty的基本使用/","content":"Netty的基本使用服务端定义开启服务端端口12345678910111213141516171819202122public class MyServer &#123; public static void main(String[] args) &#123; EventLoopGroup boseGroup = new NioEventLoopGroup(); EventLoopGroup workerGroup = new NioEventLoopGroup(); try &#123; ServerBootstrap serverBootstrap = new ServerBootstrap(); // handler 只针对boseGroup // childHandler 经过boseGroup后再经过workerGroup serverBootstrap.group(boseGroup,workerGroup).channel(NioServerSocketChannel.class) .childHandler(new MyServerInitializer()); ChannelFuture channelFuture = serverBootstrap.bind(8899).sync(); channelFuture.channel().closeFuture().sync(); &#125;catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; boseGroup.shutdownGracefully(); workerGroup.shutdownGracefully(); &#125; &#125;&#125; 定义服务端initialize1234567891011public class MyServerInitializer extends ChannelInitializer&lt;SocketChannel&gt; &#123; @Override protected void initChannel(SocketChannel ch) throws Exception &#123; ChannelPipeline pipeline = ch.pipeline(); pipeline.addLast(new LengthFieldBasedFrameDecoder(Integer.MAX_VALUE,0,4,0,4)); pipeline.addLast(new LengthFieldPrepender(4)); pipeline.addLast(new StringDecoder(CharsetUtil.UTF_8)); pipeline.addLast(new StringEncoder(CharsetUtil.UTF_8)); pipeline.addLast(new MyHttpServerHandler()); &#125;&#125; 定义服务端handler12345678910111213public class MyHttpServerHandler extends SimpleChannelInboundHandler&lt;String&gt; &#123; @Override protected void channelRead0(ChannelHandlerContext ctx, String msg) throws Exception &#123; System.out.println(ctx.channel().remoteAddress() + &quot;, &quot; + msg); ctx.channel().writeAndFlush(&quot;from server &quot;+ UUID.randomUUID()); &#125; @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123; cause.printStackTrace(); ctx.close(); &#125;&#125; 客户端定义绑定客户端端口和ip1234567891011121314151617public class MyClient &#123; public static void main(String[] args) &#123; EventLoopGroup eventExecutors = new NioEventLoopGroup(); try &#123; Bootstrap bootstrap = new Bootstrap(); bootstrap.group(eventExecutors).channel(NioSocketChannel.class) .handler(new MyClientInitializer()); ChannelFuture localhost = bootstrap.connect(&quot;localhost&quot;, 8899).sync(); localhost.channel().closeFuture().sync(); &#125;catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; eventExecutors.shutdownGracefully(); &#125; &#125;&#125; 定义客户端initialize1234567891011public class MyClientInitializer extends ChannelInitializer&lt;SocketChannel&gt; &#123; @Override protected void initChannel(SocketChannel ch) throws Exception &#123; ChannelPipeline pipeline = ch.pipeline(); pipeline.addLast(new LengthFieldBasedFrameDecoder(Integer.MAX_VALUE,0,4,0,4)); pipeline.addLast(new LengthFieldPrepender(4)); pipeline.addLast(new StringDecoder(CharsetUtil.UTF_8)); pipeline.addLast(new StringEncoder(CharsetUtil.UTF_8)); pipeline.addLast(new MyClientHandler()); &#125;&#125; 定义客户端handler12345678910111213141516171819public class MyClientHandler extends SimpleChannelInboundHandler&lt;String&gt; &#123; @Override protected void channelRead0(ChannelHandlerContext ctx, String msg) throws Exception &#123; System.out.println(ctx.channel().remoteAddress()); System.out.println(&quot;client ouput: &quot; + msg); ctx.channel().writeAndFlush(&quot;from client:&quot;+ LocalDateTime.now()); &#125; @Override public void channelActive(ChannelHandlerContext ctx) throws Exception &#123; ctx.writeAndFlush(&quot;来自于客户端的问候!&quot;); &#125; @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123; cause.printStackTrace(); ctx.close(); &#125;&#125;"},{"title":"HashMap和Hashtable的比较","path":"/2020/03/22/HashMap和Hashtable的比较/","content":"HashMap和Hashtable的比较共同点结构都是数组 + 链表的形式 存值方式都是根据key的hash计算，再将(key,value)组装为Entry或Node 区别put区别1、HashMap允许key和value都为null，而Hashtable不允许 2、HashMap是线程不安全的，Hashtable是线程安全的。 3、HashMap存值，在链表长度 &gt; 8 并且 数组长度 &lt; 64，会进行扩容，如果数组长度 &gt; 64，则将链表转换为红黑树。 Hashtable存值只有在table的size达到临界值时才会进行扩容 4、HashMap在链表存值时尾部插入，而Hashtable是头部插入","tags":["hashMap","hashtable"],"categories":["java"]},{"title":"HashMap原理分析(一)","path":"/2020/03/21/ashMap原理分析-一/","content":"HashMap的底层原理(一)组成结构数据 + 链表的形式+红黑树 12345678910111213141516// node 数组transient Node&lt;K,V&gt;[] table;// Node结构static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; final K key; V value; Node&lt;K,V&gt; next; Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125;&#125; 其他参数负载因子1234/** * The load factor used when none specified in constructor.*/static final float DEFAULT_LOAD_FACTOR = 0.75f; 链表最大长度：1static final int TREEIFY_THRESHOLD = 8; 链表转换为红黑树的重要参数12// 链表长度 &gt; 8 并且数组长度小于64那么进行扩容，否则转为红黑树static final int MIN_TREEIFY_CAPACITY = 64; 链表长度的界限1static final int TREEIFY_THRESHOLD = 8; 使用123456// 定义HashMap，初始大小可不写HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;(5);// 存放值map.put(&quot;test&quot;,&quot;name2&quot;);// 取值String test = map.get(&quot;test&quot;); 原理解析简括流程 计算key的hash,高16位于低16位进行异或运算 1return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16); 判断数组是否为空，为空时初始化。采用初次扩容。初始化的数组大小为16，扩容界限为16x0.75=12 123Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; 使用hash&amp;(n-1)获取key存放的下标位置，初始化Node，存放进Node [i] 12if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); key的hash值与初始化的第一个Node的hash一致，并且key的值也一致，直接覆盖 1234Node&lt;K,V&gt; e; K k;if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; 如果是红黑树，直接存放进红黑树内 1e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); 遍历Node链表，直到next == null，创建新的Node节点赋值给next。如果链表大小大于8个，则进行扩容或转红黑树操作 123456789101112for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e;&#125; 判断map大小是否大于扩容大小，是的话进行扩容 1234// size:hashMao大小// threshold：threshold = newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);if (++size &gt; threshold) resize(); 覆盖旧值操作 1234567if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue;&#125; 详细代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107// 扩容操作 final Node&lt;K,V&gt;[] resize() &#123; // 数组 Node&lt;K,V&gt;[] oldTab = table; // 旧数组的大小 int oldCap = (oldTab == null) ? 0 : oldTab.length; // 扩容界限 int oldThr = threshold; // 扩容后的大小，扩容后的界限 int newCap, newThr = 0; if (oldCap &gt; 0) &#123; if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; // 成倍的扩容,16 = 010000 &lt;&lt; 1 --&gt; 100000 = 32 else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold &#125; else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; else &#123; // zero initial threshold signifies using defaults // 初始化时的扩容操作 newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; // 扩容后的数据迁移 if (oldTab != null) &#123; for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; // preserve order // 扩容数据的低位链表,低位不变 Node&lt;K,V&gt; loHead = null, loTail = null; // 扩容数据的高位链表，高位迁移 Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; /** * oldCap 16: 10000 * 假设e.hash = 9 * 第一次存放的位置:01001 &amp; 01111 = 01001 = 9 * 为了保证扩容后用同样的操作取下标结果不会改变，也就是通过(n - 1) &amp; hash还会取到e * 扩容后：newCap = 32 = 100000 * 001001 &amp; 011111 = 01001 = 9 * 所以对e这个数据不改变下标位置 * 01001 &amp; * 10000 = 0 **/ if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; /** * oldCap 16: 10000 * 假设e.hash = 20 * 第一次存放的位置:10100 &amp; 01111 = 00100 = 4 * 为了保证扩容后用同样的操作取下标结果不会改变，也就是通过(n - 1) &amp; hash还会取到e * 扩容后：newCap = 32 = 100000 * 010100 &amp; 011111 = 010100 = 20 * 所以对e这个数据要改变下标位置为20 * 10100 &amp; * 10000 = 10000 != 0 * 所以要对该数据进行迁移，迁移坐标为：4 + 16(扩容的大小) = 20 **/ else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab; &#125;","tags":["HashMap"],"categories":["java"]},{"title":"一条http请求的处理过程","path":"/2020/03/21/条http请求的处理过程/","content":"一条http请求的处理过程 client发送请求DNS解析请求得域名 —&gt; ip地址TCP/IP,UDP/IP四层传输协议应用层发送http请求 传输层组装TCP头信息 —&gt; 【TCP头信息】【http请求报文】 网络层组装IP信息 —&gt; 【ip信息】【TCP头信息】【http请求报文】 网络接口层组装MAC信息 —&gt; 【MAC信息】【ip信息】【TCP头信息】【http请求报文】 网络接口层发送数据发送这样的数据：[01010110101010] 目标服务器处理数据","tags":["http"],"categories":["计算机基础"]},{"title":"redis的使用及集群","path":"/2020/03/12/redis的使用及集群/","content":"redis数据结构 ：string:set key,value ,set key value ex time map所有的键值对的键和值的长度都小于等于64byte，哈希对象保存的键值对数量都小于512：ziplist，hashtable 对象 listquicklist 消息队列 setinset：如果元素类型都是整型，并且元素个数不小于512，hashtab，点赞，互相关注 zset元素数量小于128，所有member的长度小于64字节使用ziplist，否则升级为skiplist，热点排序 ，有一个score redis常用命令listlpush：左插入数据 lpushx：做插入数据， 前提条件是key存在并且key为列表 rpush：右插入 rpushx：右插入， 前提条件是key存在并且key为列表 rpop：右弹出 lpop：左弹出 lrange：弹出一个范围内的数据 blpop：左阻塞式的弹出 brpop：右阻塞式的弹出 set1、set：sadd添加，spop删除，smembers 查看所有元素，sinter交集，sunion合集，sdiff差集 mapzsetstringredis热点数据：1、客户端统计的方式 2、代理层：TwemProxy或 Codis 3、服务端统计：monitor监控，但是只能监控到一个节点 4、机器层面：抓包的形式 redis查看内存使用信息：info memory Redis主从复制master node 第一次执行全量复制，通过bgsave命令在本地生成一份RDB文件，将RDB快照文件发送给slave节点，slave node 会先清空自己的旧数据，然后从RDB文件中加载数据。 在生成rdb文件中，master node 如果接收到新的写命令怎么办？master会把所有的新的写命令缓存在内存中，在slave node 保存了RDB文件之后，再讲新的命令复制给slave node 主从复制的不足：1、当RDB文件过大时同步非常耗时 2、在一主多从情况下，当master node 挂了后。对外服务就不可用了，单点问题并没有解决。如果每次都手动把之前的服务器切换为主服务器，这就比较费力。 可用性保证之sentinelsentinel是一个监听，监听redis集群中的master和slave，如果master一定时间内没有给sentinel回复消息，则将master标记为下线，然后把某一个slave标记为master，应用每一次都从这个监控服务器拿到master的地址。 sentinel通过info命令来获取到redis集群中的节点的信息。 服务下线：当sentinel监听到master节点下线后，会进行故障转移 故障转移：故障转移的第一步就是在sentinel集群中选举出一个leader节点，然后让这个leader指定出一个master节点。 sentinel集群选举算法类似raft算法。raft算法：首先会生成一个150-300ms的时间，默认最小时间的为leader，如果时间一样则再次生成时间。 1、master客观下线会触发选举，而不是过了时间才会 2、leader并不会把自己成为leader的信息发送给其他sentinel节点。其他sentinel等待leader从slave选举出master后，检测新的master节点正常运行后，就会去掉客观下线的标识，从而不需要进入故障转移流程。 sentienl根据什么来指定master节点：1、断开连接时间：如果与哨兵连接断开时间过长，超过了某个阈值，就直接失去了选举权， 2、优先级：如果拥有了选举权，那就判断谁的优先级更高，数值越小优先级越高 3、复制数量：如果优先级也一样，就判断谁从master节点中复制的数据最多。 4、进程id：如果复制数量一样，就选择进程id最小的那个。 哨兵机制的不足：主从切换中会丢失数据，因为只有一个master，salve节点 的数据使用RDB文件复制的。 只能单点写，没有解决扩容的问题 如果数据量过大，我们就需要多个master-slave的group redis数据的分片客户端实现客户端根据key进行hash计算，来进行分片。 ShardedJedis 代理层将分片逻辑提取出来，运行一个独立的代理服务，客户端连接到这个代理服务，代理服务做请求转发。 Twemproxy，Codis 服务层Redis Cluster","tags":["redis","中间件","缓存技术"],"categories":["中间件","Redis"]},{"title":"Java面试题整理","path":"/2020/03/04/Java面试题整理/","content":"JAVA 多个线程同时读写，读线程的数量量远远⼤大于写线程，你认为应该如何解决 并发的问题？你会选择加什么样的锁？ JAVA的AQS是否了了解，它是⼲干嘛的？ 除了了synchronized关键字之外，你是怎么来保障线程安全的？ 什么时候需要加volatile关键字？它能保证线程安全吗？ 线程池内的线程如果全部忙，提交⼀一个新的任务，会发⽣生什么？队列列全部 塞满了了之后，还是忙，再提交会发⽣生什什么？ Tomcat本身的参数你⼀一般会怎么调整？ synchronized关键字锁住的是什么东⻄西？在字节码中是怎么表示的？在内 存中的对象上表现为什么？ wait/notify/notifyAll⽅方法需不不需要被包含在synchronized块中？这是为什 么？ ExecutorService你⼀一般是怎么⽤用的？是每个service放⼀一个还是⼀一个项⽬目⾥里里⾯面放⼀一个？有什么好处？Spring 你有没有⽤用过Spring的AOP? 是⽤用来干嘛的? ⼤大概会怎么使⽤用？ 如果一个接口有2个不同的实现, 那么怎么来Autowire⼀一个指定的实现？ Spring的声明式事务 @Transaction注解⼀一般写在什么位置? 抛出了了异常会⾃自动回滚吗？有没有办法控制不不触发回滚? 如果想在某个Bean⽣生成并装配完毕后执⾏行行⾃自⼰己的逻辑，可以什么⽅方式实现？ SpringBoot没有放到web容器器⾥里里为什么能跑HTTP服务？ SpringBoot中如果你想使⽤用⾃自定义的配置⽂文件⽽而不不仅仅是application.properties，应该怎么弄弄？ SpringMVC中RequestMapping可以指定GET, POST方法么？怎么指定？ SpringMVC如果希望把输出的Object(例例如XXResult或者XXResponse)这种包装为JSON输出, 应该怎么处理理? 怎样拦截SpringMVC的异常，然后做⾃自定义的处理理，比如打⽇日志或者包装成JSONMySQL 如果有很多数据插⼊入MYSQL 你会选择什么⽅方式? 如果查询很慢，你会想到的第⼀一个⽅方式是什么？索引是⼲干嘛的? 如果建了了⼀一个单列列索引，查询的时候查出2列列，会⽤用到这个单列列索引吗？ 如果建了了⼀一个包含多个列列的索引，查询的时候只⽤用了了第⼀一列列，能不不能⽤用上这个索引？查三列列呢？ 接上题，如果where条件后⾯面带有⼀一个 i + 5 &lt; 100 会使⽤用到这个索引吗？ 怎么看是否⽤用到了了某个索引？ like %aaa%会使⽤用索引吗? like aaa%呢? drop、truncate、delete的区别？ 平时你们是怎么监控数据库的? 慢SQL是怎么排查的？ 你们数据库是否⽀支持emoji表情，如果不不⽀支持，如何操作? 你们的数据库单表数据量量是多少？⼀一般多⼤大的时候开始出现查询性能急剧下降？ 查询死掉了了，想要找出执⾏行行的查询进程⽤用什什么命令？找出来之后⼀一般你 会⼲干嘛？ 读写分离是怎么做的？你认为中间件会怎么来操作？这样操作跟事务有 什什么关系？ 分库分表有没有做过？线上的迁移过程是怎么样的？如何确定数据是正确的？JVM 你知道哪些或者你们线上使⽤用什什么GC策略略? 它有什什么优势，适⽤用于什什么场景？ JAVA类加载器器包括⼏几种？它们之间的⽗父⼦子关系是怎么样的？双亲委派机制是什什么意思？有什什么好处？ 如何⾃自定义⼀一个类加载器器？你使⽤用过哪些或者你在什什么场景下需要⼀一个⾃自定义的类加载器器吗？ 堆内存设置的参数是什什么？ Perm Space中保存什什么数据? 会引起OutOfMemory吗？ 做gc时，⼀一个对象在内存各个Space中被移动的顺序是什什么？ 你有没有遇到过OutOfMemory问题？你是怎么来处理理这个问题的？处理理过程中有哪些收获？ 1.8之后Perm Space有哪些变动? MetaSpace⼤大⼩小默认是⽆无限的么? 还是你们会通过什什么⽅方式来指定⼤大⼩小? Jstack是⼲干什什么的? Jstat呢? 如果线上程序周期性地出现卡顿，你怀疑可能是gc导致的，你会怎么来排查这个问题？线程⽇日志⼀一般你会看其中的什什么 部分？ StackOverFlow异常有没有遇到过？⼀一般你猜测会在什什么情况下被触发？如何指定⼀一个线程的堆栈⼤大⼩小？⼀一般你们写多少？Linux命令 ⽇日志特别⼤大只想看最后100⾏行行怎么弄弄? 如果想⼀一直看⽇日志的持续输出，⽤用什什么命令? 如果⽇日志⼀一边输出，⼀一边想实时看到有没有某个关键字应该怎么弄弄？ grep如果忽略略⼤大⼩小写应该怎么弄弄? 正则表达式呢？ vim往下⼀一⾏行行是什什么键？往下30⾏行行呢? 跳到⽂文件末尾⼀一⾏行行是什什么? 跳回来是什什么? 向后搜索是什什么? 如果有个⽂文本⽂文件，按空格作为列列的分隔符，如果想统计第三列列⾥里里⾯面的每个单词的出现次数应该怎么弄弄？ 如果把上⾯面的出现次数排个序应该怎么弄弄? 想按照数字本身的顺序⽽而不不是字符串串的顺序排列列怎么弄弄？ Linux环境变量量是以什什么作为分隔符的？环境变量量通过什什么命令设置？ 给某个⽂文件权设置限⽐比如设置为644 是⽤用什什么命令？这个6是什什么意思？ Linux下⾯面如果想看某个进程的资源占⽤用情况是怎么看的？系统load⼤大概 指的什什么意思？你们线上系统load⼀一般多少？如果⼀一个4核机器器，你认为多少load是⽐比较正常的？top命令⾥里里⾯面按⼀一下1会发⽣生什什么? top命令⾥里里⾯面，有时候所有进程的CPU使⽤用率加起来超过100%是怎么回 事？ 还有哪些查看系统性能或者供你发现问题的命令？你⼀一般是看哪个参数？ 想看某个进程打开了了哪些⽹网络连接是什什么命令？⾥里里⾯面连接的状态你⽐比较关⼼心哪⼏几种？ – 偏题 有没有做过Linux系统参数⽅方⾯面的优化，⼤大概优化过什什么？ 系统参数⾥里里⾯面有个叫做backlog的可以⽤用来⼲干什什么？ 查看⽹网络连接发现好多TIME_WAIT 可能是什什么原因？对你的应⽤用会有什什么影响？你会选择什什么样的⽅方式来减少这些TIME_WAIT 可否介绍⼀一下TCP三次握⼿手的过程，如果现在有个⽹网络程序，你⽤用第三⽅方 的library来发送数据，你怀疑这个library发送的数据有问题，那么怎么来验 证？tcpdump导出的⽂文件你⼀一般是怎么分析的？ KeepAlive是⽤用来⼲干什什么的？这样的好处是什什么？Redis – 开发 缓存穿透可以介绍⼀一下么？你认为应该如何解决这个问题 你是怎么触发缓存更更新的？(⽐比如设置超时时间(被动⽅方式), ⽐比如更更新的时候主动update)？如果是被动的⽅方式如何控制多个⼊入⼝口同时触发某个缓存更更新？ 你们⽤用Redis来做什什么？为什什么不不⽤用其他的KV存储例例如Memcached,Cassandra等? 你们⽤用什什么Redis客户端? Redis⾼高性能的原因⼤大概可以讲⼀一些? 你熟悉哪些Redis的数据结构? zset是⼲干什什么的? 和set有什什么区别? Redis的hash, 存储和获取的具体命令叫什什么名字? LPOP和BLPOP的区别? Redis的有⼀一些包含SCAN关键字的命令是⼲干嘛的? SCAN返回的数据量量是固定的吗? Redis中的Lua有没有使⽤用过? 可以⽤用来做什什么? 为什什么可以这么⽤用? Redis的Pipeline是⽤用来⼲干什什么的? – 运维11. Redis持久化⼤大概有⼏几种⽅方式? aof和rdb的区别是什什么? AOF有什什么优缺点吗?12. Redis Replication的⼤大致流程是什什么? bgsave这个命令的执⾏行行过程?– 偏题13. 如果有很多 KV数据要存储到Redis, 但是内存不不⾜足, 通过什什么⽅方式可以缩减内存? 为什什么这样可以缩⼩小内存?14. Redis中List, HashTable都⽤用到了了ZipList, 为什什么会选择它? 监控、稳定性 业务⽇日志是通过什什么⽅方式来收集的？ 线上机器器如何监控？采⽤用什什么开源产品或者⾃自研的产品？它是分钟级的还 是秒级的？ 如果让你来想办法收集⼀一个JAVA后端应⽤用的性能数据，你会在意哪些⽅方⾯面? 你会选择什什么样的⼯工具、思路路来收集? ⼀一般你调⽤用第三⽅方的时候会不不会监控调⽤用情况？","tags":["面试题目"],"categories":["java"]},{"title":"线程池的基本使用","path":"/2020/03/04/池的基本使用/","content":"线程池的基本使用线程池的参数：1234567public ThreadPoolExecutor(int corePoolSize,// 核心线程数 int maximumPoolSize,// 最大线程数 long keepAliveTime,// 超过核心线程数的其他线程存活时间 TimeUnit unit,// 超过核心线程数的其他线程存活时间单位 BlockingQueue&lt;Runnable&gt; workQueue,// 阻塞队列 ThreadFactory threadFactory,// 线程创建工厂 RejectedExecutionHandler handler) // 拒绝策略 阻塞队列： 类名 说明 ArrayBlockingQueue 初始化是设置queue的大小 LinkedBlockingQueue 链表实现的有界阻塞队列, 此队列的默认和最大长度为Integer.MAX_VALUE。此队列按照先进先出的原则对元素进行排序 SynchronousQueue 不存储元素的阻塞队列, 每一个 put 操作必须等待一个 take 操作，否则不能继续添加元素。 PriorityBlockingQueue 支持优先级排序的无界阻塞队列, 默认情况下元素采取自然顺序升序排列。也可以自定义类实现 compareTo()方法来指定元素排序规则，或者初始化 PriorityBlockingQueue 时，指定构造参数 Comparator 来对元素进行排序。 DelayQueue 优先级队列实现的无界阻塞队列 LinkedTransferQueue 链表实现的无界阻塞队列 LinkedBlockingDeque 链表实现的双向阻塞队列 阻塞队列的操作：增加： API 说明 add 往Queue里添加数据，如果队列满了，抛出异常 offer 往Queue里添加数据，添加成功return true，添加失败return false enqueue(不能直接使用) 添加数据的具体操作，添加完成会signal()唤醒阻塞点线程 put 添加数据，阻塞式添加。 取出： API 说明 take 阻塞式取值 dequeue(不可直接使用) 取值核心逻辑 poll 非阻塞时取值 删除：remove删除数据。","tags":["线程池","多线程"],"categories":["java"]},{"title":"Spring 的事务传播性","path":"/2020/03/04/Spring-的事务传播性/","content":"spring 的事务传播性 常量名称 常量解释 PROPAGATION_REQUIRED spring中的默认事务传播机制。支持当前事务，如果当前没有事务，就新建一个事务。 PROPAGATION_REQUIRES_NEW 新建事务，如果当前存在事务，则将当前事务挂起。新建的事务和被挂起的事务没有关联，是两个独立的事务，外层事务失败回滚后，不会影响到内层的事务。内层事务失败抛出异常后，外层事务捕获，也可以不处理回滚操作。 PROPAGITION_SUPPORTS 支持当前事务，如果当前没有事务，就以非事务方式运行 PROPAGITION_MANDATORY 支持当前事务，如果当前没有事务，则抛出异常。 PROPAGITION_NOT_SUPPORTED 以非事务方式运行，如果当前存在事务，则将当前事务挂起 PROPAGITION_NEVER 以非事务方式运行，如果当前存在事务，则抛出异常。 PROPAGITION_NESTED 如果一个活动事务存在，则运行在一个嵌套事务中。如果没有活动事务，则按REQUIRED运行。它使用了一个单独的事务，这个事务拥有多个可以回滚的保存点。内部事务的回滚不会对外部事物造成影响。他只对DataSourceTransationManager事务管理器起效。 REQUIRED 和 REQUIRES_NEW : 两个方法必须在不同的类中才会生效，才会创建新的事务。否则只会创建一个。","tags":["事务"],"categories":["Spring"]},{"title":"乐观锁和悲观锁","path":"/2020/03/04/乐观锁和悲观锁/","content":"乐观锁认为同一时间访问共享资源的线程不会冲突，所以采用共享资源的状态对资源进行修改。CAS操作也是乐观锁的体现。适合读多写少的操作。效率较高。 乐观锁的实现方式： 1、使用version方式，版本号控制对数据的操作 2、JDK的CAS操作就是乐观锁的一种实现。但是CAS可能会出现“ABA”的问题。 “ABA”问题：CAS操作表示compareAndSet,提供了三个参数，旧值V，预期值E，更新值U，当V和E相等时，才会对数据进行操作。但是操作时可能出现了其他线程对数据操作的情况：A --&gt; B --&gt;A，其他线程将数据改为B后又改回成A。所以前面的线程会对数据操作成功。类似于数据库的脏读问题 。 如何解决“ABA”问题采用version版本号控制，操作一次版本号version增加1，后续操作时带上参数version。版本号一直才会对数据操作。 悲观锁认为同一时间一定会有多个线程访问同一静态资源，所以采用对共享资源加锁的方式保证数据的安全性，如数据库操作的for update操作。","tags":["高并发","lock"],"categories":["java"]},{"title":"java中的类加载顺序","path":"/2020/03/01/ava中的类加载顺序/","content":"1234567891011121314151617public class SingletonDemo &#123; private static SingletonDemo singletonDemo = new SingletonDemo(); private static int count1; private static int count2 = 0; public SingletonDemo() &#123; count1++; count2++; System.out.println(&quot;count1:&quot; + count1);// 1 System.out.println(&quot;count2:&quot; + count2);// 2 &#125; public static void main(String[] args) &#123; System.out.println(&quot;count1:&quot; + count1);// 3 System.out.println(&quot;count2:&quot; + count2);// 4 &#125;&#125; 分析： 类的加载过程为：转载 – 链接 – 初始化 装载：根据类全路径进行加载 链接包含三个步骤：验证 - 准备 - 解析。 验证： 文件格式验证 元数据验证 字节码验证 符号引用验证 准备：为类的静态变量分配内存，并将其初始化为默认值。 解析：把类中的符号引用转换为直接引用 初始化阶段会初始化类中的： 静态成员变量singletonDemo，初始化时，count1和count2默认为0，初始化后count1和count2都是1，所以1和2位置输出均为1。 静态变量count1和count2，初始化前count1和count2都是1，初始化后count2被赋值为0。所以3和4的位置输出1,0"},{"title":"交换两个integer的值","path":"/2020/03/01/两个integer的值/","content":"核心思想：通过反射设置integer的value属性。 123456789101112131415161718192021222324public class Swap &#123; public static void main(String[] args) &#123; Integer i1 = 1; Integer i2 = 2; System.out.println(&quot;before:&quot; + &quot;i1:&quot; + i1+ &quot;- i2:&quot; + i2) ; swap(i1,i2); System.out.println(&quot;after:&quot; + &quot;i1:&quot; + i1+ &quot;- i2:&quot; + i2) ; System.out.println(new Integer(1) == i1); &#125; public static void swap(Integer i1,Integer i2) &#123; try &#123; Field field = Integer.class.getDeclaredField(&quot;value&quot;); field.setAccessible(true); int tmp = i1.intValue(); field.setInt(i1,i2); field.setInt(i2,tmp); &#125; catch (NoSuchFieldException | IllegalAccessException e) &#123; e.printStackTrace(); &#125; &#125;&#125;","tags":["面试题目","integer操作"],"categories":["java"]},{"title":"java对象的强引用、软引用、弱引用、虚引用","path":"/2020/03/01/java对象的强引用、软引用、弱引用、虚引用/","content":"强引用强引用在对象不被使用时，并且也发生了gc，但是也不会被回收，直到发生oom 12345678910/** * 强引用 */public static void strongRef() &#123; Object strongObj = obj; obj = null; System.gc(); System.out.println(strongObj);&#125;java.lang.Object@677327b6 软引用软引用在即将发生OOM时，会对没有使用的对象回收。 1234567891011/** * 软引用 */public static void softRef() &#123; Object softObj = new Object(); SoftReference softReference = new SoftReference(softObj); softObj = null; System.gc(); System.out.println(softReference.get());&#125;java.lang.Object@677327b6 弱引用发生GC时，就会对没有使用的对象进行回收。 1234567891011121314151617/** * 弱引用 */public static void weakRef() &#123; Object weakObj = new Object(); WeakReference weakReference = new WeakReference(weakObj); weakObj = null; try &#123; Thread.sleep(200); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.gc();; System.out.println(weakReference.get());&#125;java.lang.Object@677327b6null 虚引用虚引用不管在使用时还是未使用时直接取值都会是null，但是对象未被使用时(=null)会将对象放入到queue中。如果对象还在使用，则不放入。 12345678910111213141516171819/** * 虚引用 */public static void phantomRef() &#123; Object o = new Object(); ReferenceQueue queue = new ReferenceQueue(); PhantomReference phantomReference = new PhantomReference(o, queue); o = null; System.gc(); System.out.println(phantomReference.get()); try &#123; Thread.sleep(200); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(queue.poll());&#125;nulljava.lang.ref.PhantomReference@677327b6","tags":["jvm"],"categories":["java","jvm"]},{"title":"数组int[] 转换为Integer[]","path":"/2020/03/01/数组int-转换为Integer/","content":"1234int [] a = new int[]&#123;6,3,7,9&#125;;Integer[] integers = Arrays.stream(a).boxed().toArray(Integer[]::new);System.out.println(Arrays.toString(integers));","tags":["int操作","jdk1.8"],"categories":["java"]},{"title":"vps","path":"/2020/02/27/vps/","content":"下载get-pip.py1curl &quot;https://bootstrap.pypa.io/get-pip.py&quot; -o &quot;get-pip.py&quot; 执行get-pip.py1python get-pip.py 安装pip1pip install --upgrade pip 安装shadowsocks1pip install shadowsocks 配置文件12345678vi /etc/shadowsocks.json&#123; &quot;server&quot;: &quot;0.0.0.0&quot;, &quot;server_port&quot;: 2018, &quot;password&quot;: &quot;12345678&quot;, &quot;method&quot;: &quot;aes-256-cfb&quot;&#125; 启动shadowsocks1ssserver -c /etc/shadowsocks.json -d start 关闭防火墙12systemctl stop firewalld.service 关闭shadowsocks1ssserver -c /etc/shadowsocks.json -d stop","tags":["vps"],"categories":["linux"]},{"title":"About Me","path":"/2020/02/25/out-Me/","content":"A Java Coder, live in BeiJing, China.GitHub:BraveHeartQQ:318635503"},{"title":"idea快捷键使用","path":"/2019/12/31/dea快捷键使用/","content":"自动代码常用的有fori/sout/psvm+Tab即可生成循环、System.out、main方法等boilerplate样板代码 。 例如：要输入for(User user : users)只需输入user.for+Tab; 再比如：要输入Date birthday = user.getBirthday()只需输入user.getBirthday().var+Tab即可。 代码标签输入完成后，按Tab，生成代码。 Ctrl+Alt+O 优化导入的类和包 Alt+Insert 生成代码(如get,set方法,构造函数等) 或者右键（Generate） fori/sout/psvm + Tab Ctrl+Alt+T 生成try catch 或者 Alt+enter CTRL+ALT+T 把选中的代码放在 TRY{} IF{} ELSE{} 里 Ctrl + O 重写方法 Ctrl + I 实现方法 Ctr+shift+U 大小写转化 ALT+回车 导入包,自动修正 ALT+/ 代码提示 CTRL+J 自动代码 Ctrl+Shift+J，整合两行为一行 CTRL+空格 代码提示 CTRL+SHIFT+SPACE 自动补全代码 CTRL+ALT+L 格式化代码 CTRL+ALT+I 自动缩进 CTRL+ALT+O 优化导入的类和包 ALT+INSERT 生成代码(如GET,SET方法,构造函数等) CTRL+E 最近更改的代码 CTRL+ALT+SPACE 类名或接口名提示 CTRL+P 方法参数提示 CTRL+Q，可以看到当前方法的声明 Shift+F6 重构-重命名 (包、类、方法、变量、甚至注释等) Ctrl+Alt+V 提取变量 查询快捷键Ctrl＋Shift＋Backspace可以跳转到上次编辑的地CTRL+ALT+ left/right 前后导航编辑过的地方ALT+7 靠左窗口显示当前文件的结构Ctrl+F12 浮动显示当前文件的结构ALT+F7 找到你的函数或者变量或者类的所有引用到的地方CTRL+ALT+F7 找到你的函数或者变量或者类的所有引用到的地方Ctrl+Shift+Alt+N 查找类中的方法或变量双击SHIFT 在项目的所有目录查找文件Ctrl+N 查找类Ctrl+Shift+N 查找文件CTRL+G 定位行CTRL+F 在当前窗口查找文本CTRL+SHIFT+F 在指定窗口查找文本CTRL+R 在 当前窗口替换文本CTRL+SHIFT+R 在指定窗口替换文本ALT+SHIFT+C 查找修改的文件CTRL+E 最近打开的文件F3 向下查找关键字出现位置SHIFT+F3 向上一个关键字出现位置选中文本，按Alt+F3 ，高亮相同文本，F3逐个往下查找相同文本F4 查找变量来源CTRL+SHIFT+O 弹出显示查找内容Ctrl+W 选中代码，连续按会有其他效果F2 或Shift+F2 高亮错误或警告快速定位Ctrl+Up/Down 光标跳转到第一行或最后一行下Ctrl+B 快速打开光标处的类或方法CTRL+ALT+B 找所有的子类CTRL+SHIFT+B 找变量的类Ctrl+Shift+上下键 上下移动代码Ctrl+Alt+ left/right 返回至上次浏览的位置Ctrl+X 删除行Ctrl+D 复制行Ctrl+/ 或 Ctrl+Shift+/ 注释（// 或者/…/ ）Ctrl+H 显示类结构图Ctrl+Q 显示注释文档Alt+F1 查找代码所在位置Alt+1 快速打开或隐藏工程面板Alt+ left/right 切换代码视图ALT+ ↑/↓ 在方法间快速移动定位CTRL+ALT+ left/right 前后导航编辑过的地方Ctrl＋Shift＋Backspace可以跳转到上次编辑的地Alt+6 查找TODO 其他快捷键SHIFT+ENTER 另起一行CTRL+Z 倒退(撤销)CTRL+SHIFT+Z 向前(取消撤销)CTRL+ALT+F12 资源管理器打开文件夹ALT+F1 查找文件所在目录位置SHIFT+ALT+INSERT 竖编辑模式CTRL+F4 关闭当前窗口Ctrl+Alt+V，可以引入变量。例如：new String(); 自动导入变量定义Ctrl+~，快速切换方案（界面外观、代码风格、快捷键映射等菜单） svn快捷键ctrl+k 提交代码到SVNctrl+t 更新代码 调试快捷键其实常用的 就是F8 F7 F9 最值得一提的就是Drop Frame 可以让运行过的代码从头再来。 alt+F8 debug时选中查看值Alt+Shift+F9，选择 DebugAlt+Shift+F10，选择 RunCtrl+Shift+F9，编译Ctrl+Shift+F8，查看断点F7，步入Shift+F7，智能步入Alt+Shift+F7，强制步入F8，步过Shift+F8，步出Alt+Shift+F8，强制步过Alt+F9，运行至光标处Ctrl+Alt+F9，强制运行至光标处F9，恢复程序Alt+F10，定位到断点 重构Ctrl+Alt+Shift+T，弹出重构菜单Shift+F6，重命名F6，移动F5，复制Alt+Delete，安全删除Ctrl+Alt+N，内联 十大Intellij IDEA快捷键Intellij IDEA中有很多快捷键让人爱不释手，stackoverflow上也有一些有趣的讨论。每个人都有自己的最爱，想排出个理想的榜单还真是困难。 以前也整理过Intellij的快捷键，这次就按照我日常开发时的使用频率，简单分类列一下我最喜欢的十大快捷-神-键吧。 1 智能提示:Intellij首当其冲的当然就是Intelligence智能！基本的代码提示用Ctrl+Space，还有更智能地按类型信息提示Ctrl+Shift+Space，但因为Intellij总是随着我们敲击而自动提示，所以很多时候都不会手动敲这两个快捷键(除非提示框消失了)。 用F2/ Shift+F2移动到有错误的代码，Alt+Enter快速修复(即Eclipse中的Quick Fix功能)。当智能提示为我们自动补全方法名时，我们通常要自己补上行尾的反括号和分号，当括号嵌套很多层时会很麻烦，这时我们只需敲Ctrl+Shift+Enter就能自动补全末尾的字符。而且不只是括号，例如敲完if/for时也可以自动补上{}花括号。 最后要说一点，Intellij能够智能感知Spring、Hibernate等主流框架的配置文件和类，以静制动，在看似“静态”的外表下，智能地扫描理解你的项目是如何构造和配置的。 2 重构:Intellij重构是另一完爆Eclipse的功能，其智能程度令人瞠目结舌，比如提取变量时自动检查到所有匹配同时提取成一个变量等。尤其看过《重构-改善既有代码设计》之后，有了Intellij的配合简直是令人大呼过瘾！也正是强大的智能和重构功能，使Intellij下的TDD开发非常顺畅。 切入正题，先说一个无敌的重构功能大汇总快捷键Ctrl+Shift+Alt+T，叫做Refactor This。按法有点复杂，但也符合Intellij的风格，很多快捷键都要双手完成，而不像Eclipse不少最有用的快捷键可以潇洒地单手完成(不知道算不算Eclipse的一大优点)，但各位用过Emacs的话就会觉得也没什么了(非Emacs黑)。 此外，还有些最常用的重构技巧，因为太常用了，若每次都在Refactor This菜单里选的话效率有些低。比如Shift+F6直接就是改名，Ctrl+Alt+V则是提取变量。关注Java技术栈微信公众号，在后台回复关键字：IDEA，可以获取一份栈长整理的 IDEA 最新技术干货。 3 代码生成:这一点类似Eclipse，虽不是独到之处，但因为日常使用频率极高，所以还是罗列在榜单前面。常用的有fori/sout/psvm+Tab即可生成循环、System.out、main方法等boilerplate样板代码，用Ctrl+J可以查看所有模板。 后面“辅助”一节中将会讲到Alt+Insert，在编辑窗口中点击可以生成构造函数、toString、getter/setter、重写父类方法等。这两个技巧实在太常用了，几乎每天都要生成一堆main、System.out和getter/setter。 另外，Intellij IDEA 13中加入了后缀自动补全功能(Postfix Completion)，比模板生成更加灵活和强大。例如要输入for(User user : users)只需输入user.for+Tab。再比如，要输入Date birthday = user.getBirthday();只需输入user.getBirthday().var+Tab即可。 4 编辑：编辑中不得不说的一大神键就是能够自动按语法选中代码的Ctrl+W以及反向的Ctrl+Shift+W了。此外，Ctrl+Left/Right移动光标到前/后单词，Ctrl+[/]移动到前/后代码块，这些类Vim风格的光标移动也是一大亮点。以上Ctrl+Left/Right/[]加上Shift的话就能选中跳跃范围内的代码。Alt+Forward/Backward移动到前/后方法。还有些非常普通的像Ctrl+Y删除行、Ctrl+D复制行、Ctrl+折叠代码就不多说了。 关于光标移动再多扩展一点，除了Intellij本身已提供的功能外，我们还可以安装ideaVim或者emacsIDEAs享受到Vim的快速移动和Emacs的AceJump功能(超爽！)。 另外，Intellij的书签功能也是不错的，用Ctrl+Shift+Num定义1-10书签(再次按这组快捷键则是删除书签)，然后通过Ctrl+Num跳转。这避免了多次使用前/下一编辑位置Ctrl+Left/Right来回跳转的麻烦，而且此快捷键默认与Windows热键冲突(默认多了Alt，与Windows改变显示器显示方向冲突，一不小心显示器就变成倒着显式的了，冏啊)。 5 查找打开：类似Eclipse，Intellij的Ctrl+N/Ctrl+Shift+N可以打开类或资源，但Intellij更加智能一些，我们输入的任何字符都将看作模糊匹配，省却了Eclipse中还有输入*的麻烦。最新版本的IDEA还加入了Search Everywhere功能，只需按Shift+Shift即可在一个弹出框中搜索任何东西，包括类、资源、配置项、方法等等。 类的继承关系则可用Ctrl+H打开类层次窗口，在继承层次上跳转则用Ctrl+B/Ctrl+Alt+B分别对应父类或父方法定义和子类或子方法实现，查看当前类的所有方法用Ctrl+F12。 要找类或方法的使用也很简单，Alt+F7。要查找文本的出现位置就用Ctrl+F/Ctrl+Shift+F在当前窗口或全工程中查找，再配合F3/Shift+F3前后移动到下一匹配处。 Intellij更加智能的又一佐证是在任意菜单或显示窗口，都可以直接输入你要找的单词，Intellij就会自动为你过滤。 关注Java技术栈微信公众号，在后台回复关键字：IDEA，可以获取一份栈长整理的 IDEA 最新技术干货。 6 其他辅助：以上这些神键配上一些辅助快捷键，即可让你的双手90%以上的时间摆脱鼠标，专注于键盘仿佛在进行钢琴表演。这些不起眼却是至关重要的最后一块拼图有： Ø 命令：Ctrl+Shift+A可以查找所有Intellij的命令，并且每个命令后面还有其快捷键。所以它不仅是一大神键，也是查找学习快捷键的工具。 Ø 新建：Alt+Insert可以新建类、方法等任何东西。 Ø 格式化代码：格式化import列表Ctrl+Alt+O，格式化代码Ctrl+Alt+L。 Ø 切换窗口：Alt+Num，常用的有1-项目结构，3-搜索结果，4/5-运行调试。Ctrl+Tab切换标签页，Ctrl+E/Ctrl+Shift+E打开最近打开过的或编辑过的文件。 Ø 单元测试：Ctrl+Alt+T创建单元测试用例。 Ø 运行：Alt+Shift+F10运行程序，Shift+F9启动调试，Ctrl+F2停止。 Ø 调试：F7/F8/F9分别对应Step into，Step over，Continue。 此外还有些我自定义的，例如水平分屏Ctrl+|等，和一些神奇的小功能Ctrl+Shift+V粘贴很早以前拷贝过的，Alt+Shift+Insert进入到列模式进行按列选中。 Ø Top #10切来切去：Ctrl+Tab Ø Top #9选你所想：Ctrl+W Ø Top #8代码生成：Template/Postfix +Tab Ø Top #7发号施令：Ctrl+Shift+A Ø Top #6无处藏身：Shift+Shift Ø Top #5自动完成：Ctrl+Shift+Enter Ø Top #4创造万物：Alt+Insert 太难割舍，前三名并列吧！ Ø Top #1智能补全：Ctrl+Shift+Space Ø Top #1自我修复：Alt+Enter Ø Top #1重构一切：Ctrl+Shift+Alt+T CTRL+ALT+ left/right 前后导航编辑过的地方Ctrl＋Shift＋Backspace可以跳转到上次编辑的地方","tags":["idea"],"categories":["工具","idea"]},{"title":"centos7 配置jdk","path":"/2019/12/30/centos7-配置jdk/","content":"下载jdk压缩包链接：https://pan.baidu.com/s/1As4LjS8FrunJhkP16B9Xdg提取码：79es复制这段内容后打开百度网盘手机App，操作更方便哦 将jdk压缩包上传至centos7中1rz 解压jdk压缩包12tar -zxvf jdk-8u231-linux-x64.tar.gz 配置环境变量1vim /etc/profile 将下面的代码复制到最后：将第一行中路径修改为解压后的jdk目录位置 12345export JAVA_HOME=/usr/java/jdk/jdk1.8.0_231export PATH=$JAVA_HOME/bin:$PATHexportCLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar","tags":["centos7","jdk1.8"],"categories":["linux"]},{"title":"idea创建maven很慢时，设置属性","path":"/2019/12/26/ea创建maven很慢时，设置属性/","content":"1-DarchetypeCatalog=internal","tags":["maven"],"categories":["工具","maven"]},{"title":"centos 7安装redis","path":"/2019/12/18/centos 7安装redis/","content":"普通安装下载安装包1wget http://download.redis.io/releases/redis-5.0.7.tar.gz 解压文件1tar -zxvf redis-5.0.7 编译1234cd redis-5.0.7make 编译可能出现的问题12345make[1]: [persist-settings] Error 2 (ignored) CC adlist.o出现该问题时：错误是因为一些依赖包未安装yum -y install gcc gcc-c++ libstdc++-devel 解决 12345zmalloc.h:50:31: fatal error: jemalloc/jemalloc.h: No such file or directory #include &lt;jemalloc/jemalloc.h&gt; 出现该问题时：make MALLOC=libc 解决 redis设置登录密码1在redis.conf 配置文件添加`requirepass`属性保存 redis设置后台启动1在redis.conf 配置文件设置`daemonize yes`属性保存 使用docker-compose安装redis创建docker-compose.yml文件12345678910version: &#x27;2&#x27;services: redis: image: redis:5.0.5 container_name: redis command: redis-server --requirepass 123456 ports: - &quot;16379:6379&quot; volumes: - ./data:/data 启动docker-compose1docker-compose up -d 使用redis命令行客户端123456先查看redis的容器iddocker ps 进入redis容器docker exec -it 1742ad5e9da8 bash启动redis客户端redis-cli -h 127.0.0.1 -p 6379 -a 123456","tags":["redis","centos7"],"categories":["linux"]},{"title":"linux统计文件夹信息","path":"/2019/11/21/inux统计文件夹信息/","content":"查看当前文件夹所有文件的个数(不包括文件夹)1ls -l |grep &quot;^-&quot;|wc -l 查看当前文件夹所有目录的个数1ls -l |grep &quot;^ｄ&quot;|wc -l 查看当前文件夹所有文件个数(包括子目录)1ls -lR|grep &quot;^-&quot;|wc -l 查看当前文件夹下所有目录的个数(包含子目录)1ls -lR|grep &quot;^d&quot;|wc -l","tags":["命令操作","统计文件夹"],"categories":["linux"]},{"title":"centos7 mysql的安装及初始化配置","path":"/2019/11/19/ntos7-mysql启动与停止/","content":"普通方法安装安装YUM Repo由于CentOS 的yum源中没有mysql，需要到mysql的官网下载yum repo配置文件。 1wget https://dev.mysql.com/get/mysql57-community-release-el7-9.noarch.rpm 然后进行repo的安装： 1rpm -ivh mysql57-community-release-el7-9.noarch.rpm 安装mysql1yum install mysql-server 启动mysql1service mysqld start 配置MySQL获取安装时的临时密码： 1grep &#x27;temporary password&#x27; /var/log/mysqld.log 倘若没有 （1）删除原来安装过的mysql残留的数据1rm -rf /var/lib/mysql （2）再启动mysql1service mysqld start 登录1mysql -u root -p 登录成功后需要先修改密码： 1ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;123456&#x27;; 在设置密码时，但密码在简单时会出现ERROR 1819 (HY000): Your password does not satisfy the current policy requirements的错误设置参数： 12set global validate_password_policy=0;set global validate_password_length=1; 这时再设置密码就不错报错了。 修改登录权限12GRANT ALL PRIVILEGES ON *.* TO &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;123456&#x27; WITH GRANT OPTION;FLUSH PRIVILEGES; 查看mysql运行状态1service mysqld status 停止mysql1service mysqld stop 使用docker-compsoe安装创建docker-compose.yml文件1234567891011121314version: &#x27;2&#x27;services: db: image: &#x27;mysql/mysql-server:5.7&#x27; restart: always container_name: mysql57 environment: MYSQL_USER: 用户名 MYSQL_PASSWORD: 密码 MYSQL_DATABASE: 初始创建的数据库 MYSQL_ROOT_PASSWORD: root用户密码 ports: - &#x27;3306:3306&#x27;//映射端口 启动docker-compsoe12启动docker-compose(后台模式，不打印日志)docker-compose up -d 进入容器创建用户进入docker中的mysql容器查看mysql容器的id 1docker ps 进入docker容器命令行 1docker exec -it mysql容器id bash 进入mysql命令行 1mysql -u root -p 可以使用docker配置文件中创建的用户也可以创建新用户 创建新用户: 1create user &#x27;admin001&#x27;@&#x27;%&#x27; identified by &#x27;123456&#x27;; 删除用户： 1DROP USER &#x27;admin001&#x27;@&#x27;%&#x27;; 给用户赋权限： 12grant all privileges on *.* to &#x27;admin001&#x27;@&#x27;%&#x27; identified by &#x27;123456&#x27;;flush privileges;","tags":["工具使用","centos7","mysql"],"categories":["linux"]},{"title":"linux查看端口占用","path":"/2019/10/23/linux查看端口占用/","content":"1lsof -i:端口","tags":["端口查看"],"categories":["linux"]},{"title":"centos7关闭防火墙","path":"/2019/10/22/centos7关闭防火墙/","content":"1sudo systemctl stop firewalld.service &amp;&amp; sudo systemctl disable firewalld.service"},{"title":"判断一个数是否为NaN","path":"/2019/10/10/判断一个数是否为NaN/","content":"1Double.isNaN(d)","tags":["js"],"categories":["html"]},{"title":"js滚动到指定位置","path":"/2019/09/17/滚动到指定位置/","content":"1$(&quot;.html&quot;).animate(&#123;scrollTop:&#x27;0px&#x27;&#125;, 200);"},{"title":"mysql去重语句","path":"/2019/07/30/sql去除语句/","content":"1SELECT DISTINCT(u.userId) FROM `user` u where u.status=&#x27;1&#x27;;","categories":["中间件","MySQL"]},{"title":"idea去除重复代码检测","path":"/2019/07/26/ea去除重复代码检测/","content":"如图： 将红框部分去选勾选","tags":["idea"],"categories":["工具","idea"]},{"title":"excel导出poi处理及table转为excel","path":"/2019/07/26/excel导出poi处理及table转为excel/","content":"poi导出使用poi导出大量数据时，可以使用 SXSSFWorkbook 使用方法： 导入poi包及poi-ooxml包 12345678910&lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi&lt;/artifactId&gt; &lt;version&gt;3.17&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.poi&lt;/groupId&gt; &lt;artifactId&gt;poi-ooxml&lt;/artifactId&gt; &lt;version&gt;3.17&lt;/version&gt; &lt;/dependency&gt; 具体代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package com.liuyy.excel;import org.apache.poi.ss.usermodel.Font;import org.apache.poi.xssf.streaming.SXSSFCell;import org.apache.poi.xssf.streaming.SXSSFRow;import org.apache.poi.xssf.streaming.SXSSFSheet;import org.apache.poi.xssf.streaming.SXSSFWorkbook;import java.io.FileOutputStream;import java.io.IOException;/** * @author liuyy * @className PoiExcelDemo * @description TODO * @date 2019/7/26 16:55 **/public class PoiExcelDemo &#123; public static void main(String[] args) &#123; exportExcel(&quot;数据导出.xls&quot;); &#125; public static void exportExcel(String fileName)&#123; SXSSFWorkbook workbook = new SXSSFWorkbook(); //输出Excel文件 FileOutputStream output = null; try &#123; //添加Worksheet（不添加sheet时生成的xls文件打开时会报错) String sheetName = &quot;数据导出&quot;; SXSSFSheet sheet = workbook.createSheet(sheetName); // 设置缺省列高 sheet.setDefaultRowHeightInPoints(20); // 设置缺省列宽 sheet.setDefaultColumnWidth(20); // 设置字体 Font fontStyle = workbook.createFont(); fontStyle.setFontName(&quot;宋体&quot;); fontStyle.setFontHeightInPoints((short) 20); // 创建XSSFRow对象 // 创建第一行-表头 SXSSFRow rowHead = sheet.createRow(0); for (int i = 0; i &lt; 8; i++) &#123; //创建XSSFCell对象 SXSSFCell cellHead = rowHead.createCell(i); //设置单元格的值 cellHead.setCellValue(i); &#125; // 创建具体数据 for (int i = 0; i &lt; 100; i++) &#123; // 第i+1行 SXSSFRow row = sheet.createRow(i + 1); row.createCell(0).setCellValue(&quot;第1列&quot;); row.createCell(1).setCellValue(&quot;第2列&quot;); row.createCell(2).setCellValue(&quot;第3列&quot;); row.createCell(3).setCellValue(&quot;第4列&quot;); row.createCell(4).setCellValue(&quot;第5列&quot;); row.createCell(5).setCellValue(&quot;第6列&quot;); &#125; output = new FileOutputStream(fileName); workbook.write(output); output.flush(); workbook.close(); output.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; workbook.close(); output.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 结果如果所示： &#123;% asset_img pasted-5.png excel %&#125; table导出代码如下： 12345678910111213141516171819//获取表格var exportFileContent = document.getElementById(&quot;showTable&quot;).outerHTML;//设置格式为Excel，表格内容通过btoa转化为base64，此方法只在文件较小时使用(小于1M)//exportFileContent = window.btoa(unescape(encodeURIComponent(exportFileContent)));//var link = &quot;data:&quot;+MIMEType+&quot;;base64,&quot; + exportFileContent;//使用Blobvar blob = new Blob([exportFileContent], &#123;type: &quot;text/plain;charset=utf-8&quot;&#125;);//解决中文乱码问题blob = new Blob([String.fromCharCode(0xFEFF), blob], &#123;type: blob.type&#125;);//设置链接var link = window.URL.createObjectURL(blob);var a = document.createElement(&quot;a&quot;); //创建a标签a.download = filenName+&quot;.xls&quot;; //设置被下载的超链接目标（文件名）a.href = link; //设置a标签的链接document.body.appendChild(a); //a标签添加到页面a.click(); //设置a标签触发单击事件document.body.removeChild(a); //移除a标签","tags":["html","java"],"categories":["excel"]},{"title":"计算机中的二进制表示","path":"/2019/07/18/二进制表示/","content":"计算机中的整数二进制正数正数的二进制正常表示如整数5的二进制表示为0000 0000 0000 0000 0000 0000 0000 0101 负数在计算机中，负数以其正值的补码形式表达 如：-17，他的正值(17)二进制为：0000 0000 0000 0000 0000 0000 1001 0001， 补码的计算方式为：反码+1; 17的反码为：1111 1111 1111 1111 1111 1111 0110 1110， 可得-17为：1111 1111 1111 1111 1111 1111 0110 1111","tags":["二进制"],"categories":["计算机基础"]},{"title":"Integer.MAX_VALUE 面试题","path":"/2019/07/18/Integer-MAX-VALUE-面试题/","content":"如下代码：1234567final int start = Integer.MAX_VALUE-100;final int end = Integer.MAX_VALUE;int count = 0;for (int i = start; i &lt;= end;i++) &#123;\tcount++;&#125;System.out.println(count); 输出结果为？没有输出结果 分析Integer.MAX_VALUE用二进制表示1111 1111 1111 1111 1111 1111 1111 111 所以当i++一直到=end时，即i = Integer.MAX_VALUE时,此时计算的结果为100，但是当接着往下面执行时，i++即 i = Integer.MAX_VALUE+1，i此时二进制1111 1111 1111 1111 1111 1111 1111 111 + 1 的结果为-1000 0000 0000 0000 0000 0000 0000 0000，即i = -2147483648，符合 i &lt; end条件，所以循环接着往下执行，一直到=end，+1后又变为负数，周而复始，所以不会有结果输出。","tags":["java"],"categories":["java"]},{"title":"short/int 易错面试题","path":"/2019/07/18/short/int 易错面试题/","content":"12345678910HashSet&lt;Short&gt; set = new HashSet&lt;&gt;();for (short i = 0; i &lt; 100; i++) &#123; // set.add set添加的类型为short set.add(i); // 通过计算得知 int i1 = i - 1,i-1返回的是一个int类型的值，所以remove时找不到需要remove的值 set.remove(i-1);&#125;// 从而size是100System.out.println(set.size());","tags":["java"],"categories":["java"]},{"title":"远程通讯协议-tcp/ip及nio的学习笔记","path":"/2019/07/17/程通讯协议-tcp-ip及nio的学习笔记/","content":"tcp 7层 应用层 表示层 会话层 传输层 网络层 数据链路层 物理层 4层网络模型： 其中应用层、表示层、会话层表示应用层，数据链路层、物理层表示网络接口层 ARP协议复杂的程序都需要分层，软件开发设计必须要做的 tcp负载均衡二层负载 -&gt; mac地址，vip(虚拟ip) 多个机器IP相同但是mac地址不同 三层负载 -&gt;ip 对外提供虚拟ip，集群中不同机器采用不用的ip，IP请求转发 四层负载 -&gt; 传输层负载，包含ip和端口，修改目标ip和端口地址 七层负载 -&gt; 应用层负载，请求的url，http请求的报文，如http://a/a.html,主机名。 tcp和udp区别TCP/IP：可靠 建立连接机制 三次握手建立连接 client发送请求连接的数据包 server返回可以进行连接的数据包 client发送确认请求连接的数据包 client/server可以进行数据传输了 SYNC攻击 -&gt; 客户端伪造大量ip和mac地址发送消息给服务器，占用服务器大量资源 连接的关闭，四次挥手协议 client发送请求关闭连接的数据包 server返回确认收到请求关闭的数据包-此时server可能还处于数据操作的状况 server数据已经处理完毕，并返回可以关闭的数据包 client返回最终请求关闭数据包-此时server接收到数据包以后将处于关闭状态,而client可能还处于数据为未接受完的状态，等待2个固定的时间点后进入关闭状态 TCP是一种全双工的协议 长连接，正常连接是超时关闭，但是长连接可以发送心跳包维持连接 UDP/IP：不可靠 在应用中如何去构建一个传输的实例socket -&gt; 套接字 socket io file io 通讯过程中的阻塞accept阻塞(连接阻塞) 流操作的阻塞(read/write) 滑动窗口的协议流量控制BIO模型 ​ blocker io 阻塞 优化方案： 可以解决socket io阻塞，但是还是存在file io阻塞问题 123456789101112131415ServerSocket server = new ServerSocket(8080);while(true) &#123; Socket socket = server.accpet(); new Thread(new SocketThread(socket)).start;&#125;public class SocketThread implements Runnable&#123; Socket socket; public SocketThread(Socket socket) &#123; this.socket = socket; &#125; public void run() &#123; // 对socket进行操作 &#125;&#125; NIO非阻塞 ​ new io / non blocker io 多路复用机制 linux fd：linux系统中一切皆可看成是文件，文件描述符是内核为了高效管理已被打开的文件所创建的索引 serverSocket 向请求内核 先监听socket/fd，再如果发现socket/fd已就绪，就发送数据已经准备好的通知(即可以像该文件进行读写)，然后serverSocket再来发送read/write请求 linux提供的io复用机制 select/poll：轮询查询socket/fd是否已经就绪 epoll：事件机制，理解为注册监听机制，如果发现socket/fd就绪直接返回就绪通知，可以进行读写 服务端的机器怎么去标记一个个的连接四元组：source_ip/source_port/target_ip/target_port 因为目标机器的ip和端口固定，所以最大连接数取决于客户端的数量 source_ip : 2^32 source_port:2^16 因为0不能作为端口，所以是65535个 内存大小 文件句柄的限制 ulimit -n 默认是1024 带宽的资源","tags":["网络"],"categories":["计算机基础"]},{"title":"jdk8 部分新特性","path":"/2019/07/11/java8-lambda语法/","content":"jdk1.8 时间的创建及工具类1234567891011121314151617181920212223242526272829303132333435// ClockClock clock = Clock.systemDefaultZone();System.out.println(clock.millis());Instant instant = clock.instant();System.out.println(instant);Date from = Date.from(instant);System.out.println(from);// 时区// 获取所有时区Set&lt;String&gt; availableZoneIds = ZoneId.getAvailableZoneIds();System.out.println(availableZoneIds);// 获取指定时区的ZoneIdZoneId of = ZoneId.of(&quot;Asia/Aden&quot;);System.out.println(of.getRules());// localtime 获取指定时区的时间LocalTime now = LocalTime.now(of);System.out.println(&quot;当前时间是：&quot;+now);// localData 本地日期LocalDate today = LocalDate.now();System.out.println(&quot;今天的日期是：&quot;+today);LocalDate tomorrow = today.plus(1, ChronoUnit.DAYS);System.out.println(&quot;明天的日期是：&quot;+tomorrow);LocalDate yesterday = today.plus(-1, ChronoUnit.DAYS);System.out.println(&quot;昨天的日期是：&quot;+yesterday);// 创建指定日期LocalDate of1 = LocalDate.of(2019, Month.JUNE, 11);System.out.println(of1);DayOfWeek dayOfWeek = of1.getDayOfWeek();System.out.println(&quot;今天是周几：&quot;+dayOfWeek);// DateTimeFormatter格式化时间DateTimeFormatter formatter = DateTimeFormatter.ofPattern(&quot;yyyy年MM月dd日&quot;);String format = formatter.format(today);System.out.println(format); Stream12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970List&lt;String&gt; stringList = new ArrayList&lt;&gt;();stringList.add(&quot;ddd2&quot;);stringList.add(&quot;aaa2&quot;);stringList.add(&quot;bbb1&quot;);stringList.add(&quot;aaa1&quot;);stringList.add(&quot;bbb3&quot;);stringList.add(&quot;ccc&quot;);stringList.add(&quot;bbb2&quot;);stringList.add(&quot;ddd1&quot;);// stream 串行// 过滤stringList .stream() .filter(s -&gt; s.startsWith(&quot;a&quot;)) .forEach(System.out::println);System.out.println(&quot;-----------------------&quot;);// 排序// 排序只是创建了一个排序好的stream，原数据并没有改变stringList .stream() .sorted() .filter(s -&gt; s.startsWith(&quot;a&quot;)) .forEach(System.out::println);System.out.println(&quot;-----------------------&quot;);// map映射,map操作stringList .stream() .map(String::toUpperCase) .sorted((o1, o2) -&gt; o2.compareTo(o1)) .forEach(System.out::println);System.out.println(&quot;-----------------------&quot;);// 匹配，任一一个匹配就可以返回boolean anyMatch = stringList .stream() .anyMatch(s -&gt; s.startsWith(&quot;a&quot;));System.out.println(anyMatch);System.out.println(&quot;-----------------------&quot;);// 匹配，所有匹配，所有匹配到才会返回trueboolean allMatch = stringList .stream() .allMatch(s -&gt; s.startsWith(&quot;a&quot;));System.out.println(allMatch);System.out.println(&quot;-----------------------&quot;);// 匹配,没有匹配到的返回true，如果有匹配到的则返回falseboolean noneMatch = stringList .stream() .noneMatch(s -&gt; s.startsWith(&quot;a&quot;));System.out.println(noneMatch);System.out.println(&quot;-----------------------&quot;);// 计数long count = stringList .stream() .filter(s -&gt; s.startsWith(&quot;a&quot;)) .count();System.out.println(count);System.out.println(&quot;-----------------------&quot;);// 规约,将集合整合为一个元素Optional&lt;String&gt; reduce = stringList .stream() .sorted() .reduce((s, s2) -&gt; s + &quot;#&quot; + s2);reduce.ifPresent(System.out::println); lambda语法创建接口1234567891011public interface InteTest &#123; void initData(String string);&#125;public class Test &#123; public static void main(String[] args) &#123; InteTest inteTest = string -&gt; &#123; System.out.println(string); &#125;; inteTest.initData(&quot;123&quot;); &#125;&#125;","tags":["java"],"categories":["java"]},{"title":"微服务及SpringCloud的一些面试问题","path":"/2019/07/02/微服务及SpringCloud的一些面试问题/","content":"soa和微服务的区别 soa:面向服务的框架，着重于将应用系统根据不同的业务模块拆分不同的服务，并通过这些服务定义好的接口联系起来。它是一种粗粒度，松耦合的框架，主要解决的是服务重复性问题。 微服务:微服务是soa架构下的最终产物，它相对soa来说对系统的拆分更加彻底，拆分粒度更细，拆分后的服务都可以单独的运行。微服务主要解决的是服务的高耦合问题，通过降低服务之间的耦合度来把服务分割的更彻底，每个服务都可以不依赖于其他服务而独立运行，当一个服务出问题时，对其他服务并不会造成影响。 soa和微服务都是分布式的具体实现思想。 你是怎么理解微服务的？ 微服务顾名思义就是将系统拆分为一个个可以独立部署、水平扩展、独立运行的细微服务。 使用微服务的思想通过对单体架构的系统进行细粒度的拆分，从而降低各个服务之间的耦合度，单个服务中如果出现问题而不会对其他服务产生影响。并且通过对系统的拆分，会极大的解决原单体架构系统中的有些业务运行速度过慢而对其他业务造成的影响。 什么是SpringCloud SpringCloud可以通俗的理解为整合各个分布式基础设施的工具箱，它是一系列框架的有序集合，注重于服务治理。 微服务架构的优点和缺点有哪些？ 微服务的主要作用是大型业务系统进行细粒度的拆分，从而降低项目开发时某一模块的开发对其他模块业务开发的影响，可以将项目中的各个模块更快地上线落地，相对传统的单体架构中一块出问题其他都会被影响，微服务带来的是更加敏捷的更新维护，当其中一个服务出问题时，其他服务不会受到影响。但是当系统拆分的太细致，造成的运维成本也相对的更大，梳理各服务的功能调用逻辑更麻烦，本来只需要对一个系统的维护现在变相的变成对多个系统的维护，这样的成本会大大的增大。 SpringCloud解决了什么问题？ SpringCloud利用SpringBoot的开发便利性简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、熔断器、数据监控、负载均衡等，都可以利用SpringBoot的开发风格做到一键部署和启动。","tags":["java","SpringCloud","微服务"],"categories":["java"]},{"title":"java并发编程-volatile关键字","path":"/2019/06/26/java并发编程-volatile关键字/","content":"并发编程MESI协议基于失效的缓存一致性协议 有四个状态: Exclusive(E)：独享，其他缓存都没有有效的副本 Shared(S)：共享，其他缓存都有有效的副本 Invalid(I)：失效 Modified(M)：修改 原子性、有序性、可见性原子性在java中，对基本数据类型的变量读取和赋值操作是原子性操作，这些操作是不可中断的，也就是要么读，要么不读，或者要么写要么不写。 12345x = 10; // 操作1y = x;\t// 操作2x++;\t// 操作3x = x + 1;//操作4 以上的操作中只有操作1属于原子性操作。 有序性有以下这样的代码： 1234567891011121314int x = 10;//volatile int x = 10; 如果x有volatile关键字修饰时,就可以保证有序性void cpu0()&#123; x = 100;// 此时x的状态变幻情况为：S(共享) -&gt; M(修改),此时通过cpu0会通知其他cpu的x的值为I(失效)，再取出最新值，会消耗一段时间才会将x的值修改完成 flag = true;// 当flag此时是E状态时，变化状态:E(独享) -&gt; M(修改)，此时flag的值会直接修改，并发送给其他cpu状态置为S(共享)&#125;void cpu1()&#123;\twhile(flag) &#123; System.out.println(x == 100); &#125;&#125; 当有volatile关键字修饰时，会看到在程序运行时的汇编指令中会发现有locak指令，相当于一个内存屏障，会强制把缓存的操作写入主存。 当不能保证有序性时，打印输出的结果可能为false。所以在程序运行必须保证有序性。 可见性在Java中，提供了volatile关键保证可见性。当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。此外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。 volatile、synchronizedvolatile可以保证对变量操作的有序性、可见性，但是不能保证原子性 synchronized可以保证对变量的有序性、可见性、原子性","tags":["java"],"categories":["java"]},{"title":"linux的5种io模型","path":"/2019/06/11/linux的5中io模型/","content":"linux的5种io模型阻塞式io非阻塞式io信号驱动式ioio复用模式异步io","tags":["linux"],"categories":["linux"]},{"title":"URL与URI的区别","path":"/2019/06/05/RL与URI的区别/","content":"URL、URI的区别定义URL:统一资源定位符代表的是一个具体的资源位置，如http://localhost:8081/spring/demo/query?name=1 URI：统一资源标识符用于标识互联网资源名称的字符串，URI最常见的形式是URL，所有URL是URI的子集，URI属于URL更好层次的抽象，一种字符串文本标准。如/spring/demo/query，着重于表示资源的名称 组成URIWeb上可用的每种资源如HTML文档、图像、视频片段、程序等都是一个来URI来定位的. URLURL可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录 一个URL例如：http://localhost:8081/spring/demo/query?name=1 组成部分为：schema://host[:port]/path/…/?[url-params]#[query-string] 包含以下组成部分： schema：指定应用层使用的协议，例如：http，https，ftp host：http服务器的域名或ip port：端口，可选项，80端口可以不填，如果使用了其他端口，则必须说明 path：请求的路径 query-string：请求参数"},{"title":"Arrays.asList()的使用","path":"/2019/05/29/代码示例/","content":"Arrays.asList()的使用代码：12345678910111213141516171819202122232425262728293031323334353637383940public class ArraysToListTest &#123; public static void main(String[] args) &#123; int[] nums = &#123;1,2,3,4,5&#125;; printArrays(nums); List&lt;int[]&gt; ints = Arrays.asList(nums); printArrays(ints); Integer[] integers = &#123;1,2,3,4,5&#125;; printArrays(integers); List&lt;Integer&gt; integerList = Arrays.asList(integers); printArrays(integerList); &#125; public static void printArrays(List list)&#123; list.forEach(o -&gt; &#123; if (o instanceof int[]) &#123; printArrays((int[]) o); &#125;else &#123; System.out.println(o); &#125; &#125;); System.out.println(); &#125; public static void printArrays(Integer[] nums)&#123; for (int i = 0; i &lt; nums.length; i++) &#123; int num = nums[i]; System.out.print(num+&quot; &quot;); &#125; System.out.println(); &#125; public static void printArrays(int[] nums)&#123; for (int i = 0; i &lt; nums.length; i++) &#123; int num = nums[i]; System.out.print(num+&quot; &quot;); &#125; System.out.println(); &#125;&#125; 总结： 当使用Arrays.asList(nums);转换的数组内容为基本数据类型时，转换后的list集合的存放的也是这个基本数据类型的数组，而不是这个基本数据类型的值。 如果要对转换后的list进行增删改操作，则需要以new的方式来创建list 解决方法：使用其包装类型: 123Integer[] integers = &#123;1,2,3,4,5&#125;;List&lt;Integer&gt; integerList = new ArrayList&lt;&gt;(Arrays.asList(integers));","tags":["java"],"categories":["java"]},{"title":"Java Integer(-128~127)值的==和equals比较","path":"/2019/05/29/java-Integer-128-127-值的-和equals比较/","content":"Integer有如下代码： 123456789101112131415161718192021222324Integer i1 = 127;Integer i2 = 127;System.out.print(i1+&quot; == &quot;+i2+&quot; :&quot;+(i1 == i2));System.out.println(&quot; &quot;+i1+&quot;.equals(&quot;+i2+&quot;) :&quot;+(i1.equals(i2)));Integer i3 = 128;Integer i4 = 128;System.out.print(i3+&quot; == &quot;+i4+&quot; :&quot;+(i3 == i4));System.out.println(&quot; &quot;+i3+&quot;.equals(&quot;+i4+&quot;) :&quot;+(i3.equals(i4)));Integer i5 = new Integer(127);Integer i6 = new Integer(127);System.out.print(i5+&quot; == &quot;+i6+&quot; :&quot;+(i5 == i6));System.out.println(&quot; &quot;+i5+&quot;.equals(&quot;+i6+&quot;) :&quot;+(i5.equals(i6)));Integer i7 = new Integer(128);Integer i8 = new Integer(128);System.out.print(i7+&quot; == &quot;+i8+&quot; :&quot;+(i7 == i8));System.out.println(&quot; &quot;+i7+&quot;.equals(&quot;+i8+&quot;) :&quot;+(i7.equals(i8)));Integer i9 = new Integer(40);Integer i10 = new Integer(40);Integer i11 = new Integer(0);System.out.println(&quot;i9=i10+i11 &quot; + (i9 == i10 + i11)); 输出结果如下： 12345127 == 127 :true 127.equals(127) :true128 == 128 :false 128.equals(128) :true127 == 127 :false 127.equals(127) :true128 == 128 :false 128.equals(128) :truei9=i10+i11 true 总结: 在-128~127的Integer值如果以Integer x = value;的方式赋值的Integer值在进行==和equals比较时，都会返回true 在-128~127之外的以Integer x = value;的方式赋值的Integer值在进行==和equals比较时，返回结果并不下相同 无论是在-128~127还是之外的Integer值如果以Integer x = new Integer(value);的方式赋值的Integer值在进行==和equals比较时,返回结果都并不x相同 因为Java里面对处在在-128127之间的使用Integer x = value;赋值的Integer值，用的是原生数据类型int，会在内存里供重用，也就是说这之间的Integer值进行==比较时只是进行int原生数据类型的数值比较，而超出-128127的范围，进行==比较时是进行地址及数值比较。 而对于所有以Integer x = new Integer(value);赋值的Integer值，使用== 比较时是进行地址及数值比较。 语句 i9 == i10 + i11，因为+这个操作符不适用于 Integer 对象，首先 i10 和 i11 进行自动拆箱操作，进行数值相加，即 i9 == 40。然后 Integer 对象无法与数值进行直接比较，所以 i9 自动拆箱转为 int 值 40，最终这条语句转为 40 == 40 进行数值比较 所以在比较包装类型的值时，必须使用equals进行比较","tags":["java","Integer"],"categories":["java"]},{"title":"单例模式的基础知识","path":"/2019/05/29/模式/","content":"单例模式单例模式的优缺点优点 内存消耗小 全局只有一个实例 缺点 没有接口，扩展困难 如果要扩展单例，只能修改代码 创建单例的方法饿汉式模式 直接创建-消耗内存-线程不安全 静态创建-线程不安全 懒汉式模式 判断为空再创建-线程不安全 双重检验为空再创建 使用synchronize关键字-线程安全 静态内部类创建-线程安全 注册式创建 简单注册-spring 枚举类创建 序列化线程池关于单例模式的问题spring的单例会被回收吗？ 注册式单例，被保存在ioc的缓存容器中，给每个实例起个名字，叫beanName、id ioc容器持有单例对象的引用 当对象为null或引用不被任何地方所持有时会被回收 ioc容器本身也是个单例，ioc容器什么时候被回收，那么ioc中的beanName也就什么时候被回收 ioc容器实在spring启动时初始化，在spring销毁时被回收 spring中的单例Bean跟ioc容器同生死 spring的单例是线程安全的吗？ 它由在beanFactory中由反射机制创建，被缓存到ioc容器中，相当于new Object() 所以他是线程安全的","tags":["设计模式","单例模式"],"categories":["java","设计模式"]},{"title":"markdown特殊语法","path":"/2019/05/22/markdown特殊语法/","content":"插入图片123&#123;% asset_img clipboard.png 图片1 %&#125;","tags":["markdown"],"categories":["工具"]},{"title":"linux命令","path":"/2019/05/15/linux命令/","content":"linux命令上传-下载文件上传和下载文件使用rz和sz命令 使用以下命令安装rz和sz： 1yum install -y lrzsz 上传输入以下命令： 1rz 打开选择文件窗口 选择文件即可上传 下载输入以下命令： 1sz 文件名 打开文件要下载的地址 选择路径下载即可 ssh传输文件123scp test.zip admin@192.168.1.1:/test解析：scp 文件名 ssh地址:要复制的文件到远程机的路径 vi编辑器123456789101112131415161718192021222324252627282930313233343536打开文件：vi test.txtCtrl+u：向文件首翻半屏；Ctrl+d：向文件尾翻半屏；Ctrl+f：向文件尾翻一屏；Ctrl+b：向文件首翻一屏；Esc：从编辑模式切换到命令模式；ZZ：命令模式下保存当前文件所做的修改后退出vi；:行号：光标跳转到指定行的行首；:$：光标跳转到最后一行的行首；x或X：删除一个字符，x删除光标后的，而X删除光标前的；D：删除从当前光标到光标所在行尾的全部字符；dd：删除光标行正行内容；ndd：删除当前行及其后n-1行；nyy：将当前行及其下n行的内容保存到寄存器？中，其中？为一个字母，n为一个数字；p：粘贴文本操作，用于将缓存区的内容粘贴到当前光标所在位置的下方；P：粘贴文本操作，用于将缓存区的内容粘贴到当前光标所在位置的上方；/字符串：文本查找操作，用于从当前光标所在位置开始向文件尾部查找指定字符串的内容，查找的字符串会被加亮显示；？字符串：文本查找操作，用于从当前光标所在位置开始向文件头部查找指定字符串的内容，查找的字符串会被加亮显示；a，bs/F/T：替换文本操作，用于在第a行到第b行之间，将F字符串换成T字符串。其中，“s/”表示进行替换操作；a：在当前字符后添加文本；A：在行末添加文本；i：在当前字符前插入文本；I：在行首插入文本；o：在当前行后面插入一空行；O：在当前行前面插入一空行；:wq：在命令模式下，执行存盘退出操作；:w：在命令模式下，执行存盘操作；:w！：在命令模式下，执行强制存盘操作；:q：在命令模式下，执行退出vi操作；:q！：在命令模式下，执行强制退出vi操作；:e文件名：在命令模式下，打开并编辑指定名称的文件；:n：在命令模式下，如果同时打开多个文件，则继续编辑下一个文件；:f：在命令模式下，用于显示当前的文件名、光标所在行的行号以及显示比例；:set number：在命令模式下，用于在最左端显示行号；:set nonumber：在命令模式下，用于在最左端不显示行号；","tags":["linux"],"categories":["linux"]},{"title":"动态壁纸","path":"/2019/05/15/动态壁纸/","content":"动态壁纸软件 Wallpaper Engine","tags":["壁纸工具"],"categories":["工具"]},{"title":"opencv参考链接","path":"/2019/05/06/opencv参考链接/","content":"基于java的opencv、tesseractc参考链接 Intellij Idea 部署 OpenCV-4.0.0 环境 如何使用Tesseract和OpenCV执行OCR和文本识别 tesseract官方文档 OpenCV Java Tutorials documentation! Tesseract-OCR识别中文与训练字库实例 Tesseract-OCR识别中文与训练字库实例","tags":["java","ocr","oepncv","testseract"],"categories":["人工识别"]},{"title":"git提交","path":"/2019/05/06/git提交/","content":"git提交步骤 git init //初始化仓库 git add .(文件name) //添加文件到本地仓库 git commit -m “first commit” //添加文件描述信息 git remote add origin + 远程仓库地址 //链接远程仓库，创建主分支 git pull origin master // 把本地仓库的变化连接到远程仓库主分支 git push -u origin master //把本地仓库的文件推送到远程仓库 强制提交如果确定代码无误，可以强制提交 git push -f 错误处理1fatal: refusing to merge unrelated histories 在merge、pull或push中出现以上错误，可以使用以下命令： 12345678910merge时：git merge master --allow-unrelated-historiespull时：git pull origin master --allow-unrelated-historiespush时：git push -u origin master --allow-unrelated-histories","tags":["git"],"categories":["工具"]},{"title":"html5 audio配合span data-src-mp3使用","path":"/2019/04/26/html5 audio配合span data-src-mp3使用/","content":"html5 audio配合span data-src-mp3使用编写html代码1234567&lt;audio id=&quot;player&quot; style=&quot;display: none&quot;&gt;&lt;/audio&gt;&lt;span class = &#x27;1&#x27; data-src-mp3=&quot;&quot; data-src-ogg=&quot;&quot;&gt;&lt;/span&gt; &lt;span class = &#x27;2&#x27; data-src-mp3=&quot;&quot; data-src-ogg=&quot;&quot;&gt;&lt;/span&gt; 初始化span标签123456$(&quot;span.1&quot;) .attr(&quot;data-src-mp3&quot;,&quot;song1.mp3&quot;) .attr(&quot;data-src-ogg&quot;,&quot;song1.ogg&quot;);$(&quot;span.2&quot;) .attr(&quot;data-src-mp3&quot;,&quot;song2.mp3&quot;) .attr(&quot;data-src-ogg&quot;,&quot;song2.ogg&quot;); 控制播放1234567891011121314151617181920212223$(&quot;span[data-src-mp3]&quot;).click(function () &#123; var player = document.getElementById(&quot;player&quot;), $this = $(this); if ($this.hasClass(&quot;selected&quot;)) &#123; if (player.paused) &#123; player.play(); &#125; else &#123; player.pause(); &#125; &#125; else &#123; $(&quot;span[data-src-mp3].selected&quot;).removeClass(&quot;selected&quot;); $this.addClass(&quot;selected&quot;); $(player) .empty() .append($(&quot;&lt;source&gt;&quot;).attr(&quot;src&quot;, $this.attr(&quot;data-src-mp3&quot;))) .append($(&quot;&lt;source&gt;&quot;).attr(&quot;src&quot;, $this.attr(&quot;data-src-ogg&quot;))) // 必须使用load重新加载audio，否则播放audio时，播放出来的还是最初始的资源 player.load(); player.play(); &#125;&#125;);","tags":["audio","html5"],"categories":["html"]},{"title":"SpringBoot项目基础搭建","path":"/2019/03/15/SpringBoot项目基础搭建/","content":"什么是spring bootSpring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式，Spring Boot致力于在蓬勃发展的快速应用开发领域(rapid application development)成为领导者。 — 来自百度百科 springboot 的特点 创建独立的Spring应用程序 嵌入的Tomcat，无需部署WAR文件 简化Maven配置 自动配置Spring 提供生产就绪型功能，如指标，健康检查和外部配置 绝对没有代码生成并且对XML也没有配置要求 使用spring boot有什么好处简单、快速、方便！平时如果我们需要搭建一个spring web项目的时候需要怎么做呢？ 1）配置web.xml，加载spring和spring mvc 2）配置数据库连接、配置spring事务 3）配置加载配置文件的读取，开启注解 4）配置日志文件 … 配置完成之后部署tomcat 调试 … 快速入门maven构建项目使用工具：IntelliJ IDEA 2018.3.4、jdk1.8.0_201 在idea界面点击 Create New project,然后点击Next 选择Spring Initializar点击Next 设置初始java包结构点击Next 在此步骤选择springboot集成的其他框架，如mysql然后点击Next 输入项目名称，点击***finish***即可完成创建springboot项目 项目结构如下： src/main/java/: 程序开发及主程序入口 src/main/resources/: 配置文件 src/test: 测试程序 引入web模块1、在pom文件中添加web模块依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; pom.xml文件中默认有两个模块： spring-boot-starter：核心模块，包括自动配置支持、日志和YAML； spring-boot-starter-test：测试模块，包括JUnit、Hamcrest、Mockito。 2、编写 HelloWorldController1234567@RestControllerpublic class HelloWorldController &#123;\t@RequestMapping(&quot;/hello&quot;)\tprivate String hello()&#123; return &quot;hello world&quot;; &#125;&#125; @RestController的意思就是controller里面的方法都以json格式输出. 3、启动主程序在浏览器打开http://127.0.0.1:8080/hello,即可看到结果 开发环境的调试springBoot对调试支持很好，修改之后可以实时生效，需要添加以下的配置： 12345678910111213141516171819&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;fork&gt;true&lt;/fork&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 该模块在完整的打包环境下运行的时候会被禁用。如果你使用java -jar启动应用或者用一个特定的classloader启动，它会认为这是一个“生产环境”。","tags":["SpringBoot"],"categories":["Spring","SpringBoot"]},{"title":"excel数据处理","path":"/2019/03/14/excel数据处理/","content":"excel中把一列数据中第一个空格前后的内容分为两列设原内容在A列，则 12B1=LEFT(A1,FIND(&quot;&quot;,A1))C1=MID(A1,FIND(&quot;&quot;,A1)+1,LEN(A1)) 在一组数据中筛选包含另一组数据的某个数据的单元 使用MATCH(A2,$B$2:$B$13,0) 公式里第三个参数的含义： 返回结果为位置，如果只需要知道是否存在则可用： IF(MATCH(A2,$B$2:$B$13,0)&gt;0,TRUE)","tags":["excel"],"categories":["计算机基础"]},{"title":"mysql删除语句使用","path":"/2019/03/14/mysql删除语句使用/","content":"mysql删除语句使用12delete t from table_name t where t.id = 1 mysql 清空表数据1truncate table table_name;","tags":["MySQL"],"categories":["中间件","MySQL"]},{"title":"服务器桌面端差异","path":"/2019/03/14/服务器桌面端差异/","content":"javax.net.ssl.SSLKeyException: RSA premaster secret error错误的解决办法： 找到jre环境的lib/ext/sunjce_provider.jar 把这个放到程序的lib下","tags":["java"],"categories":["问题处理"]},{"title":"maven导出所有使用的jar包","path":"/2019/03/14/maven导出所有使用的jar包/","content":"maven导出所有使用的jar包: mvn dependency:copy-dependencies -DoutputDirectory=lib -DincludeScope=compile","tags":["maven"],"categories":["java"]},{"title":"cmd运行java","path":"/2019/03/14/cmd运行java/","content":"用命令行编译运行带有包或使用外部jar包的情况1234567编译：javac -Djava.ext.dirs=./lib Test.java 或 javac -Djava.ext.dirs=D:/javacode/lib运行：java -Djava.ext.dirs=./lib Test 将日志保存至文件中：java -Djava.ext.dirs=./lib Test &gt;&gt; log.txt","tags":["cmd"],"categories":["java"]},{"title":"notepad++ 字符串匹配","path":"/2019/03/12/notepad-字符串匹配/","content":"匹配模式查找：a.+?da 表示查找以a开头a结尾的","tags":["notepad++"],"categories":["工具"]},{"title":"python格式化字符串","path":"/2019/03/12/python格式化字符串/","content":"格式化字符串各符号表示：%d - 整数 %s - 字符串 %f - 浮点数 %x - 十六进制整数 实例print(&#39;%2d-%02d&#39; % (3, 1)) print(&#39;%.2f&#39; % 3.1415926) 解释： %后数字若为一位表示位数，如若两位，第一位是补充数字，第二位是位数 浮点数前加. %%表示转义为%","tags":["python"],"categories":["python"]},{"title":"windows特殊字符","path":"/2019/03/12/windows/","content":"windows特殊字符版权符号：alt+169 © 拼音：版权 ©","tags":["windows"],"categories":["工具"]},{"title":"docker&tomcat","path":"/2019/03/12/docker-tomcat/","content":"docker 简介 **image(镜像)**：对比iso镜像文件，不可操作，只能被pull下载下来使用或push将自己的镜像上传上去 container(容器): 对比iso镜像中的live cd模式，不用直接安装需要的东西即可直接使用。但是一旦容器关闭，那么在容器中安装的vim或gcc都将会被销毁。如果要保存这些，就需要将当前容器封装成自己的镜像。 **repository(仓库)**： 类似于git，既可以将自己在git上下载下来的代码上传上去，也可以将自己上传上去的代码下载下来。只需要有别人的镜像的名字，标签。自己也可以将自己的镜像设置为私有。 docker 启动和停止1234停止当前tomcat应用：docker-compose down启动tomcat应用：docker-compose up -d docker compose映射端口将容器的8000端口映射到宿主机上的7001端口: docker compose run -p 7001:8000 web python a.py runserver 0.0.0.0:8000 使用-p命令映射端口后，访问web应用需访问宿主机的端口7001 启动注意docker compose run启动一个容器时，如果service中有--link指定的其他服务没有运行，会先运行这些服务，–link依赖的这些服务都运行后，才会执行指定的命令。如果不想启动依赖的其他服务，可以使用--no-deps标识。docker compnse run --no-deps web python manage.py shell","tags":["docker","tomcat"],"categories":["java"]},{"title":"jfinal 文件上传特殊处理","path":"/2019/03/12/jinal/","content":"jfinal 文件上传特殊处理如果页面中form中有enctype=&quot;multipart/form-data&quot;属性，在后台接收数据时先使用getFile，再使用getPara();","tags":["jfinal"],"categories":["java"]},{"title":"js特殊用法","path":"/2019/03/12/js特殊用法/","content":"jquery获取jsonJS里使用 $!{string} 获取原格式的字符串； 出现此种错误时，将*${}* 改为*$!{}* 使用 js 动态元素选择器123var i=1;var head=&quot;head&quot;+i;$(&quot;#head&quot;+head+&quot;&quot;); 使用js处理双击、选中事件jquery 处理方式1$(document.body).on(&#x27;mouseup&#x27;,&quot;#content&quot;,mouseUp); dom处理方式：12document.addEventListener(&quot;dblclick&quot;, doubleClick, true); 释放鼠标处理函数123456789101112function mouseUp() &#123; var text = &quot;&quot;; if (window.getSelection) &#123; text = window.getSelection().toString(); &#125; else if (document.selection &amp;&amp; document.selection.type != &quot;Control&quot;) &#123; text = document.selection.createRange().text; &#125; if (&quot;&quot; != text&amp;&amp;&quot; &quot; != text) &#123; $(&quot;#checkText&quot;).val(text); layer.msg(text); &#125;&#125; js计算1234parseInt(5/2); 结果：2 舍弃小数部分，取整数Math.ceil(5/2); 结果：3 向上取整，有小时就整数加一Math.round(5/2);结果：3 四舍五入Math.floor(5/2);结果：2 向下取整 js给指定一篇文章添加行号123456789101112131415161718192021222324252627282930313233343536373839404142434445function getLineNum()&#123;var $lineNum=$(&quot;#lineNum&quot;);$lineNum.empty();var rowNum=Math.round(document.getElementById(&quot;contentT&quot;).scrollHeight/parseFloat($(&quot;#contentT&quot;).css(&quot;line-height&quot;)));console.log(&quot;$(&#x27;.article fl&#x27;).height():&quot;+document.getElementById(&quot;contentT&quot;).scrollHeight);console.log(&quot;parseFloat($(&#x27;.article fl&#x27;).css(&#x27;line-height&#x27;)):&quot;+parseFloat($(&quot;#contentT&quot;).css(&quot;line-height&quot;)));console.log(rowNum);for(var i=1;i&lt;rowNum;i++)&#123;\tvar flag=false;\tif(headNum&gt;1)&#123; for(var j=2;j&lt;=headNum;j++)&#123; var headId=&quot;head&quot;+j; var $headEle=$(&quot;#&quot;+headId+&quot;&quot;); var offsetTop=$headEle.position().top; var headRow=Math.round(offsetTop/parseFloat($(&quot;#contentT&quot;).css(&quot;line-height&quot;))); headRow=headRow+1; if(headRow==i)&#123; flag=true; break; &#125; &#125;\t&#125;\tif(flag)&#123; if(i%5==0||i==1)&#123; $lineNum.append(&quot;&lt;br&gt;&lt;p&gt;&quot;+i+&quot;&lt;/p&gt;&quot;); &#125;else&#123; $lineNum.append(&quot;&lt;br&gt;&lt;br&gt;&quot;); &#125;\t&#125;else&#123; if(i%5==0)&#123; $lineNum.append(&quot;&lt;p&gt;&quot;+i+&quot;&lt;/p&gt;&quot;); &#125;else if(i==1)&#123; $lineNum.append(&quot;&lt;p&gt;&quot;+i+&quot;&lt;/p&gt;&quot;); &#125;else&#123; $lineNum.append(&quot;&lt;br&gt;&quot;); &#125;\t&#125;&#125;&#125;; js对象转换jquery对象&lt;-&gt;dom对象dom对象转换为jquery对象：12var d=document.getElementById(&quot;id&quot;);\t//对象d为DOM对象var s=$(d);\t//对象s为Jquery对象 jquery对象转换为dom对象：123var d=document.getElementById(&quot;id&quot;); //对象d为DOM对象var s=$(d);\t//对象s为Jquery对象var dd=s.get(0)\t//对象dd为DOM对象 js随机打乱数组 1234567function randomsort(a, b) &#123; return Math.random()&gt;.5 ? -1 : 1; //用Math.random()函数生成0~1之间的随机数与0.5比较，返回-1或1&#125;var arr = [1, 2, 3, 4, 5];arr.sort(randomsort); js从数组中获取指定个数的随机数据12345678910111213141516/** * 从数组中随机取指定数量的数据 * @param arr 数据 * @param count 随机数量 * @returns &#123;*&#125; */function getRandomArrayElements(arr, count) &#123; var shuffled = arr.slice(0), i = arr.length, min = i - count, temp, index; while (i-- &gt; min) &#123; index = Math.floor((i + 1) * Math.random()); temp = shuffled[index]; shuffled[index] = shuffled[i]; shuffled[i] = temp; &#125; return shuffled.slice(min);&#125; js禁止双击12&lt;body onselectstart = &quot;return false&quot; style = &#123; -moz-user-select : none &#125;&gt;&lt;/body&gt; js控制div里的滚动条12$(&#x27;.dtcon&#x27;).animate(&#123;scrollTop:&#x27;0px&#x27;&#125;, 200);200:滚动条移动至指定位置所需时间 ms","tags":["JavaScript"],"categories":["html"]},{"title":"form表单外不同的按钮提交到不同的url","path":"/2019/03/08/form表单外不同的按钮提交到不同的url/","content":"form表单外不同的按钮提交到不同的url1234567891011121314151617181920&lt;form hidden=&quot;&quot; id=&quot;form&quot; method=&quot;post&quot;&gt;\t&lt;input type=&quot;text&quot; value=&quot;&quot; name=&quot;rel&quot; id=&quot;rel&quot;&gt;\t&lt;input type=&quot;text&quot; value=&quot;&quot; name=&quot;answer&quot; id=&quot;answer&quot;&gt;\t&lt;input type=&quot;text&quot; value=&quot;&quot; name=&quot;curPage&quot; id=&quot;curPage&quot;&gt;\t&lt;input type=&quot;text&quot; value=&quot;&quot; name=&quot;examName&quot; id=&quot;examName&quot;&gt;&lt;/form&gt;&lt;button typr=&#x27;button&#x27; id=&#x27;but1&#x27; class=&#x27;but1&#x27;&gt;&lt;/button&gt;&lt;button typr=&#x27;button&#x27; id=&#x27;but2&#x27; class=&#x27;but2&#x27;&gt;&lt;/button&gt;&lt;script&gt; $(document).on(&#x27;click&#x27;,&#x27;button.but1&#x27;,function()&#123; $(&quot;#form&quot;).attr(&quot;action&quot;,&quot;url&quot;); $(&quot;#form&quot;).submit(); &#125;) $(document).on(&#x27;click&#x27;,&#x27;button.but1&#x27;,function()&#123; $(&quot;#form&quot;).attr(&quot;action&quot;,&quot;url&quot;); $(&quot;#form&quot;).submit(); &#125;)&lt;/script&gt;","tags":["html"],"categories":["html"]}]